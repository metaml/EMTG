// Copyright (c) 2023 The Regents of the University of Colorado.
// All Other Rights Reserved.

//missionoptions class
//auto-generated by make_EMTG_missionoptions_journeyoptions.py

#include "missionoptions.h"
#include "file_utilities.h"
#include "EMTG_math.h"

#ifdef EMTG_OPTIONS_PYTHON_INTERFACE
#include "PyMissionOptions.h"
#endif

#include <iostream>
#include <fstream>
#include <sstream>
#include <exception>

namespace EMTG
{
    //constructor - just initializes everything
    missionoptions::missionoptions()
    {
        //values
        this->Journeys.push_back(EMTG::JourneyOptions()); //default mission has one default journey
        this->number_of_journeys = this->Journeys.size();
        this->G = 6.674280000000000367e-20;
        this->g0 = 9.806649999999999423;
        this->AU = 1.49597870691e+8;

        this->mission_name = "default";
        this->objective_type = (ObjectiveFunctionType) 2;
        this->objective_journey = 0;
        this->include_initial_impulse_in_cost = (bool) 0;
        this->global_timebounded = (bool) 1;
        this->launch_window_open_date = 53782 * 86400.0;
        this->total_flight_time_bounds = std::vector<double>({ 0.0 * 86400.0, 302 * 86400.0}); 
        this->DLA_bounds = std::vector<double>({ -90.0, 90.0}); 
        this->RLA_bounds = std::vector<double>({ -2880.0, 2880.0}); 
        this->mission_type = (PhaseType) 2;
        this->NLP_solver_type = 0;
        this->NLP_solver_mode = (NLPMode) 1;
        this->quiet_NLP = (bool) 1;
        this->ACE_feasible_point_finder = (bool) 0;
        this->MBH_always_write_archive = (bool) 0;
        this->MBH_archive_state_vector = (bool) 0;
        this->MBH_max_not_improve = 10000;
        this->MBH_max_trials = 1000000;
        this->MBH_max_run_time = 60;
        this->MBH_max_step_size = 1;
        this->MBH_hop_distribution = 2;
        this->MBH_Pareto_alpha = 1.4;
        this->MBH_write_every_improvement = (bool) 0;
        this->MBH_time_hop_probability = 0.05;
        this->snopt_feasibility_tolerance = 1.00E-05;
        this->snopt_optimality_tolerance = 1.00E-05;
        this->NLP_max_step = 1;
        this->snopt_major_iterations = 8000;
        this->snopt_minor_iterations = 500;
        this->snopt_max_run_time = 15;
        this->enable_Scalatron = (bool) 1;
        this->enable_NLP_chaperone = (bool) 1;
        this->seed_MBH = (bool) 0;
        this->skip_first_nlp_run = (bool) 0;
        this->NLP_stop_on_goal_attain = (bool) 0;
        this->NLP_objective_goal = 0;
        this->MBH_RNG_seed = -1;
        this->print_NLP_movie_frames = (bool) 0;
        this->quiet_basinhopping = (bool) 0;
        this->SPICE_leap_seconds_kernel = "naif0012.tls";
        this->SPICE_reference_frame_kernel = "pck00010.tpc";
        this->universe_folder = "C:/Utilities/Universe";
        this->ephemeris_source = 2;
        this->SplineEphem_points_per_period = 360;
        this->SplineEphem_non_central_body_sun_points_per_period = 10000;
        this->SplineEphem_truncate_ephemeris_at_maximum_mission_epoch = (bool) 0;
        this->earliestPossibleEpoch = 51554.5;
        this->latestPossibleEpoch = 88058;
        this->propagatorType = (PropagatorType) 0;
        this->integratorType = (IntegratorType) 1;
        this->integrator_tolerance = 1.00E-08;
        this->integration_time_step_size = 86400;
        this->num_timesteps = 20;
        this->spiral_segments = 1;
        this->allow_initial_mass_to_vary = (bool) 0;
        this->maximum_mass = 525.2;
        this->IspLT = 3000;
        this->IspLT_minimum = 1;
        this->IspChem = 320;
        this->Thrust = 0.1;
        this->LV_margin = 0;
        this->LV_adapter_mass = 0;
        this->engine_type = 5;
        this->number_of_electric_propulsion_systems = 1;
        this->engine_duty_cycle = 1;
        this->duty_cycle_type = (DutyCycleType) 0;
        this->thrust_scale_factor = 1;
        this->power_at_1_AU = 5;
        this->power_source_type = (SpacecraftPowerSupplyType) 1;
        this->solar_power_model_type = (SpacecraftPowerSupplyCurveType) 0;
        this->solar_power_gamma = std::vector<double>({ 1.32077, -0.10848, -0.11665, 0.10843, -0.01279, 0.0, 0.0}); 
        this->power_margin = 0;
        this->power_decay_rate = 0;
        this->power_decay_type = 0;
        this->decay_coefficients = std::vector<double>({ 1, 0, 0, 0}); 
        this->power_system_decay_reference_epoch = 51544.5 * 86400.0;
        this->throttle_sharpness = 100;
        this->throttle_logic_mode = (ThrottleLogic) 1;
        this->spacecraft_power_coefficients = std::vector<double>({ 0, 0, 0}); 
        this->engine_input_thrust_coefficients = std::vector<double>({ 26.337459, -51.694393, 90.486509, -36.720293, 5.145602, 0.0, 0.0}); 
        this->engine_input_mass_flow_rate_coefficients = std::vector<double>({ 2.506, -5.3568, 6.2539, -2.5372, 0.36985, 0.0, 0.0}); 
        this->engine_input_power_bounds = std::vector<double>({ 0.525, 2.6}); 
        this->user_defined_engine_efficiency = 0.7;
        this->spacecraft_power_model_type = (SpacecraftBusPowerType) 0;
        this->TCM_Isp = 200;
        this->TCM_post_launch = 0;
        this->TCM_pre_flyby = 0;
        this->TCM_maneuver_fraction = 0;
        this->trackACS = (bool) 0;
        this->ACS_kg_per_day = 0;
        this->final_mass_constraint_bounds = std::vector<double>({ 0.0, 0.0}); 
        this->constrain_final_mass = (bool) 0;
        this->constrain_dry_mass = (bool) 0;
        this->enable_electric_propellant_tank_constraint = (bool) 0;
        this->maximum_electric_propellant = 1000;
        this->electric_propellant_margin = 0;
        this->enable_chemical_propellant_tank_constraint = (bool) 0;
        this->maximum_chemical_fuel = 1000;
        this->maximum_chemical_oxidizer = 1000;
        this->bipropellant_mixture_ratio = 0.925;
        this->chemical_propellant_margin = 0;
        this->SpacecraftModelInput = (SpacecraftModelInputType) 2;
        this->HardwarePath = "c:/Utilities/HardwareModels/";
        this->ThrottleTableFile = "empty.ThrottleTable";
        this->LaunchVehicleLibraryFile = "default.emtg_launchvehicleopt";
        this->PowerSystemsLibraryFile = "default.emtg_powersystemsopt";
        this->PropulsionSystemsLibraryFile = "default.emtg_propulsionsystemopt";
        this->SpacecraftOptionsFile = "default.emtg_spacecraftopt";
        this->LaunchVehicleKey = "ExampleRocket";
        this->PowerSystemKey = "5kW_basic";
        this->ElectricPropulsionSystemKey = "defaultThruster";
        this->ChemicalPropulsionSystemKey = "DefaultChemicalPropulsionSystem";
        this->perturb_SRP = (bool) 0;
        this->perturb_thirdbody = (bool) 0;
        this->perturb_J2 = (bool) 0;
        this->spacecraft_area = 70;
        this->coefficient_of_reflectivity = 1;
        this->solar_percentage = (double ) 1;
        this->solar_flux = 1359.39;
        this->speed_of_light_vac = 299792458;
        this->forced_post_launch_coast = 0 * 86400.0;
        this->forced_pre_flyby_coast = 0 * 86400.0;
        this->forced_post_flyby_coast = 0 * 86400.0;
        this->waypoint_file_path = "./banana.ephemeris";
        this->covariance_file_path = "./shampoo_bottle.ephemeris";
        this->ParallelShootingStateRepresentation = (StateRepresentation) 1;
        this->PeriapseBoundaryStateRepresentation = (StateRepresentation) 1;
        this->ParallelShootingConstraintStateRepresentation = (ConstraintStateRepresentation) 0;
        this->print_only_non_default_options = (bool) 1;
        this->output_file_frame = (ReferenceFrame) 1;
        this->override_default_output_file_name = (bool) 0;
        this->forced_output_file_name = "forced_output_file_name";
        this->output_dormant_journeys = (bool) 0;
        this->post_mission_wait_time = 0;
        this->override_working_directory = (bool) 0;
        this->forced_working_directory = "..//EMTG_v9_Results";
        this->override_mission_subfolder = (bool) 0;
        this->forced_mission_subfolder = "mission_subfolder";
        this->short_output_file_names = (bool) 1;
        this->generate_forward_integrated_ephemeris = (bool) 0;
        this->forward_integrated_ephemeris_central_body_SPICE_ID = 10;
        this->add_control_switch_line_to_ephemeris = (bool) 0;
        this->append_mass_to_ephemeris_output = (bool) 0;
        this->append_control_to_ephemeris_output = (bool) 0;
        this->append_thrust_to_ephemeris_output = (bool) 0;
        this->append_mdot_to_ephemeris_output = (bool) 0;
        this->append_Isp_to_ephemeris_output = (bool) 0;
        this->append_active_power_to_ephemeris_output = (bool) 0;
        this->append_number_of_active_engines_to_ephemeris_output = (bool) 0;
        this->append_throttle_level_to_ephemeris_output = (bool) 0;
        this->call_system_to_generate_bsp = (bool) 0;
        this->spice_utilities_path = "c:/utilities/cspice/exe";
        this->spice_utility_extension = ".exe";
        this->pyemtg_path = "c:/emtg/PyEMTG/";
        this->spacecraft_SPICE_ID = -52284;
        this->background_mode = (bool) 0;
        this->output_STMs = (bool) 0;
        this->output_maneuver_and_target_spec_files = (bool) 0;
        this->generate_acceleration_model_instrumentation_file = (bool) 0;
        this->stop_after_journey = 32767;
        this->run_inner_loop = (InnerLoopSolverType) 1;
        this->check_derivatives = (bool) 0;
        
        //bounds
        this->objective_type_lowerBound = (ObjectiveFunctionType) 0;
        this->objective_type_upperBound = (ObjectiveFunctionType) 27;
        this->objective_journey_lowerBound = 0;
        this->objective_journey_upperBound = SIZE_MAX;
        this->launch_window_open_date_lowerBound = 0 * 86400.0;
        this->launch_window_open_date_upperBound = math::LARGE * 86400.0;
        this->total_flight_time_bounds_lowerBound = std::vector<double>({ 0.0 * 86400.0,  1e-10 * 86400.0}); 
        this->total_flight_time_bounds_upperBound = std::vector<double>({ math::LARGE * 86400.0,  math::LARGE * 86400.0}); 
        this->DLA_bounds_lowerBound = std::vector<double>({ -90.0,  -90.0}); 
        this->DLA_bounds_upperBound = std::vector<double>({ 90.0,  90.0}); 
        this->RLA_bounds_lowerBound = -math::LARGE;
        this->RLA_bounds_upperBound = math::LARGE;
        this->mission_type_lowerBound = (PhaseType) 0;
        this->mission_type_upperBound = (PhaseType) 11;
        this->NLP_solver_type_lowerBound = 0;
        this->NLP_solver_type_upperBound = 3;
        this->NLP_solver_mode_lowerBound = (NLPMode) 0;
        this->NLP_solver_mode_upperBound = (NLPMode) 2;
        this->MBH_max_not_improve_lowerBound = 1;
        this->MBH_max_not_improve_upperBound = INT_MAX;
        this->MBH_max_trials_lowerBound = 1;
        this->MBH_max_trials_upperBound = INT_MAX;
        this->MBH_max_run_time_lowerBound = 0;
        this->MBH_max_run_time_upperBound = INT_MAX;
        this->MBH_max_step_size_lowerBound = 1.00E-10;
        this->MBH_max_step_size_upperBound = math::LARGE;
        this->MBH_hop_distribution_lowerBound = 0;
        this->MBH_hop_distribution_upperBound = 3;
        this->MBH_Pareto_alpha_lowerBound = 1.00E-10;
        this->MBH_Pareto_alpha_upperBound = math::LARGE;
        this->MBH_time_hop_probability_lowerBound = 0;
        this->MBH_time_hop_probability_upperBound = 1;
        this->snopt_feasibility_tolerance_lowerBound = 1.00E-10;
        this->snopt_feasibility_tolerance_upperBound = 1;
        this->snopt_optimality_tolerance_lowerBound = 1.00E-10;
        this->snopt_optimality_tolerance_upperBound = 1;
        this->NLP_max_step_lowerBound = 1.00E-10;
        this->NLP_max_step_upperBound = 1;
        this->snopt_major_iterations_lowerBound = 0;
        this->snopt_major_iterations_upperBound = SIZE_MAX;
        this->snopt_minor_iterations_lowerBound = 0;
        this->snopt_minor_iterations_upperBound = SIZE_MAX;
        this->snopt_max_run_time_lowerBound = 0;
        this->snopt_max_run_time_upperBound = INT_MAX;
        this->NLP_objective_goal_lowerBound = -math::LARGE;
        this->NLP_objective_goal_upperBound = math::LARGE;
        this->MBH_RNG_seed_lowerBound = -INT_MAX;
        this->MBH_RNG_seed_upperBound = INT_MAX;
        this->ephemeris_source_lowerBound = 0;
        this->ephemeris_source_upperBound = 2;
        this->SplineEphem_points_per_period_lowerBound = 1;
        this->SplineEphem_points_per_period_upperBound = SIZE_MAX;
        this->SplineEphem_non_central_body_sun_points_per_period_lowerBound = 1;
        this->SplineEphem_non_central_body_sun_points_per_period_upperBound = SIZE_MAX;
        this->earliestPossibleEpoch_lowerBound = 33251;
        this->earliestPossibleEpoch_upperBound = 100000;
        this->latestPossibleEpoch_lowerBound = 33251;
        this->latestPossibleEpoch_upperBound = 100000;
        this->propagatorType_lowerBound = (PropagatorType) 0;
        this->propagatorType_upperBound = (PropagatorType) 1;
        this->integratorType_lowerBound = (IntegratorType) 0;
        this->integratorType_upperBound = (IntegratorType) 1;
        this->integrator_tolerance_lowerBound = 1.00E-12;
        this->integrator_tolerance_upperBound = 1;
        this->integration_time_step_size_lowerBound = 1.00E-10;
        this->integration_time_step_size_upperBound = math::LARGE;
        this->num_timesteps_lowerBound = 1;
        this->num_timesteps_upperBound = INT_MAX;
        this->spiral_segments_lowerBound = 1;
        this->spiral_segments_upperBound = SIZE_MAX;
        this->maximum_mass_lowerBound = 1.00E-10;
        this->maximum_mass_upperBound = math::LARGE;
        this->IspLT_lowerBound = 1;
        this->IspLT_upperBound = math::LARGE;
        this->IspLT_minimum_lowerBound = 1;
        this->IspLT_minimum_upperBound = math::LARGE;
        this->IspChem_lowerBound = 1;
        this->IspChem_upperBound = math::LARGE;
        this->Thrust_lowerBound = 1.00E-10;
        this->Thrust_upperBound = math::LARGE;
        this->LV_margin_lowerBound = 0;
        this->LV_margin_upperBound = 1;
        this->LV_adapter_mass_lowerBound = 0;
        this->LV_adapter_mass_upperBound = math::LARGE;
        this->engine_type_lowerBound = 0;
        this->engine_type_upperBound = 32;
        this->number_of_electric_propulsion_systems_lowerBound = 1;
        this->number_of_electric_propulsion_systems_upperBound = INT_MAX;
        this->engine_duty_cycle_lowerBound = 1.00E-10;
        this->engine_duty_cycle_upperBound = 1;
        this->duty_cycle_type_lowerBound = (DutyCycleType) 0;
        this->duty_cycle_type_upperBound = (DutyCycleType) 1;
        this->thrust_scale_factor_lowerBound = 1.00E-10;
        this->thrust_scale_factor_upperBound = 1;
        this->power_at_1_AU_lowerBound = 1.00E-10;
        this->power_at_1_AU_upperBound = math::LARGE;
        this->power_source_type_lowerBound = (SpacecraftPowerSupplyType) 0;
        this->power_source_type_upperBound = (SpacecraftPowerSupplyType) 1;
        this->solar_power_model_type_lowerBound = (SpacecraftPowerSupplyCurveType) 0;
        this->solar_power_model_type_upperBound = (SpacecraftPowerSupplyCurveType) 1;
        this->solar_power_gamma_lowerBound = -math::LARGE;
        this->solar_power_gamma_upperBound = math::LARGE;
        this->power_margin_lowerBound = 0;
        this->power_margin_upperBound = 1;
        this->power_decay_rate_lowerBound = 0;
        this->power_decay_rate_upperBound = 1;
        this->power_decay_type_lowerBound = 0;
        this->power_decay_type_upperBound = 1;
        this->decay_coefficients_lowerBound = -math::LARGE;
        this->decay_coefficients_upperBound = math::LARGE;
        this->power_system_decay_reference_epoch_lowerBound = 0 * 86400.0;
        this->power_system_decay_reference_epoch_upperBound = math::LARGE * 86400.0;
        this->throttle_sharpness_lowerBound = 1;
        this->throttle_sharpness_upperBound = 100000;
        this->throttle_logic_mode_lowerBound = (ThrottleLogic) 0;
        this->throttle_logic_mode_upperBound = (ThrottleLogic) 1;
        this->spacecraft_power_coefficients_lowerBound = -math::LARGE;
        this->spacecraft_power_coefficients_upperBound = math::LARGE;
        this->engine_input_thrust_coefficients_lowerBound = -math::LARGE;
        this->engine_input_thrust_coefficients_upperBound = math::LARGE;
        this->engine_input_mass_flow_rate_coefficients_lowerBound = -math::LARGE;
        this->engine_input_mass_flow_rate_coefficients_upperBound = math::LARGE;
        this->engine_input_power_bounds_lowerBound = 0;
        this->engine_input_power_bounds_upperBound = math::LARGE;
        this->user_defined_engine_efficiency_lowerBound = 1.00E-10;
        this->user_defined_engine_efficiency_upperBound = 1;
        this->spacecraft_power_model_type_lowerBound = (SpacecraftBusPowerType) 0;
        this->spacecraft_power_model_type_upperBound = (SpacecraftBusPowerType) 1;
        this->TCM_Isp_lowerBound = 1;
        this->TCM_Isp_upperBound = math::LARGE;
        this->TCM_post_launch_lowerBound = 0;
        this->TCM_post_launch_upperBound = math::LARGE;
        this->TCM_pre_flyby_lowerBound = 0;
        this->TCM_pre_flyby_upperBound = math::LARGE;
        this->TCM_maneuver_fraction_lowerBound = 0;
        this->TCM_maneuver_fraction_upperBound = 1;
        this->ACS_kg_per_day_lowerBound = 0;
        this->ACS_kg_per_day_upperBound = math::LARGE;
        this->final_mass_constraint_bounds_lowerBound = 0;
        this->final_mass_constraint_bounds_upperBound = math::LARGE;
        this->maximum_electric_propellant_lowerBound = 0;
        this->maximum_electric_propellant_upperBound = math::LARGE;
        this->electric_propellant_margin_lowerBound = 0;
        this->electric_propellant_margin_upperBound = 1;
        this->maximum_chemical_fuel_lowerBound = 0;
        this->maximum_chemical_fuel_upperBound = math::LARGE;
        this->maximum_chemical_oxidizer_lowerBound = 0;
        this->maximum_chemical_oxidizer_upperBound = math::LARGE;
        this->bipropellant_mixture_ratio_lowerBound = 1.00E-10;
        this->bipropellant_mixture_ratio_upperBound = 1;
        this->chemical_propellant_margin_lowerBound = 0;
        this->chemical_propellant_margin_upperBound = 1;
        this->SpacecraftModelInput_lowerBound = (SpacecraftModelInputType) 0;
        this->SpacecraftModelInput_upperBound = (SpacecraftModelInputType) 2;
        this->spacecraft_area_lowerBound = 0;
        this->spacecraft_area_upperBound = math::LARGE;
        this->coefficient_of_reflectivity_lowerBound = 0;
        this->coefficient_of_reflectivity_upperBound = math::LARGE;
        this->solar_percentage_lowerBound = (double ) 0;
        this->solar_percentage_upperBound = (double ) 1;
        this->solar_flux_lowerBound = 0;
        this->solar_flux_upperBound = math::LARGE;
        this->speed_of_light_vac_lowerBound = 0;
        this->speed_of_light_vac_upperBound = math::LARGE;
        this->forced_post_launch_coast_lowerBound = 0 * 86400.0;
        this->forced_post_launch_coast_upperBound = math::LARGE * 86400.0;
        this->forced_pre_flyby_coast_lowerBound = 0 * 86400.0;
        this->forced_pre_flyby_coast_upperBound = math::LARGE * 86400.0;
        this->forced_post_flyby_coast_lowerBound = 0 * 86400.0;
        this->forced_post_flyby_coast_upperBound = math::LARGE * 86400.0;
        this->ParallelShootingStateRepresentation_lowerBound = (StateRepresentation) 0;
        this->ParallelShootingStateRepresentation_upperBound = (StateRepresentation) 4;
        this->PeriapseBoundaryStateRepresentation_lowerBound = (StateRepresentation) 0;
        this->PeriapseBoundaryStateRepresentation_upperBound = (StateRepresentation) 6;
        this->ParallelShootingConstraintStateRepresentation_lowerBound = (ConstraintStateRepresentation) 0;
        this->ParallelShootingConstraintStateRepresentation_upperBound = (ConstraintStateRepresentation) 1;
        this->output_file_frame_lowerBound = (ReferenceFrame) 0;
        this->output_file_frame_upperBound = (ReferenceFrame) 7;
        this->post_mission_wait_time_lowerBound = 0;
        this->post_mission_wait_time_upperBound = math::LARGE;
        this->forward_integrated_ephemeris_central_body_SPICE_ID_lowerBound = -INT_MAX;
        this->forward_integrated_ephemeris_central_body_SPICE_ID_upperBound = INT_MAX;
        this->spacecraft_SPICE_ID_lowerBound = -INT_MAX;
        this->spacecraft_SPICE_ID_upperBound = INT_MAX;
        this->stop_after_journey_lowerBound = 0;
        this->stop_after_journey_upperBound = SIZE_MAX;
        this->run_inner_loop_lowerBound = (InnerLoopSolverType) 0;
        this->run_inner_loop_upperBound = (InnerLoopSolverType) 4;
    }//end constructor
    
    missionoptions::missionoptions(std::string optionsfilename) : missionoptions()
    {
        this->parse_mission(optionsfilename);
    }//end constructor with input file
    
    //parsers
    void missionoptions::parse_mission(const std::string& optionsfilename)
    {
        std::ifstream optionsFileStream;
        optionsFileStream.open(optionsfilename);
        
        if (!optionsFileStream.is_open())
        {
            throw std::invalid_argument("Cannot find options file: " + optionsfilename);
        }
        
        std::string line;
        bool firstJourney = true;
        size_t lineNumber = 0;
        
        while (EMTG::file_utilities::safeGetline(optionsFileStream, line))
        {
            if (line.size() > 0) //skip blank lines
            {
                if (line.front() == *"#") //skip comment lines
                {
                    ++lineNumber;
                }
                else if (line == "BEGIN_JOURNEY")
                {
                    if (firstJourney)
                    {
                        firstJourney = false;
                        this->Journeys.clear();
                    };
                    
                    ++lineNumber;
                    this->Journeys.push_back(EMTG::JourneyOptions(optionsFileStream, lineNumber));
                }
                else
                {
                    this->parse_line(line, lineNumber);
                }
            }
        }

        this->number_of_journeys = this->Journeys.size();

        for (EMTG::JourneyOptions& myJourney : this->Journeys)
            myJourney.maximum_mass = this->maximum_mass;

        this->assemble_initial_guess();
    }//end parse_mission()
    
    void missionoptions::parse_line(const std::string& line, size_t& lineNumber)
    {
        ++lineNumber;
        
        std::vector<std::string> linecell;
        boost::split(linecell, line, boost::is_any_of(" "), boost::token_compress_on);
        
        if (linecell[0] == "mission_name")
        {
            this->mission_name = linecell[1];
            return;
        }
        if (linecell[0] == "objective_type")
        {
            this->objective_type = (ObjectiveFunctionType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->objective_type < this->objective_type_lowerBound || this->objective_type > this->objective_type_upperBound)
            {
                throw std::out_of_range("Input option objective_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->objective_type) + ", bounds are [" + std::to_string(this->objective_type_lowerBound) + ", " + std::to_string(this->objective_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "objective_journey")
        {
            this->objective_journey = std::stoi(linecell[1]);
            
            //bounds check
            if (this->objective_journey < this->objective_journey_lowerBound || this->objective_journey > this->objective_journey_upperBound)
            {
                throw std::out_of_range("Input option objective_journey is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->objective_journey) + ", bounds are [" + std::to_string(this->objective_journey_lowerBound) + ", " + std::to_string(this->objective_journey_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "include_initial_impulse_in_cost")
        {
            this->include_initial_impulse_in_cost = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "global_timebounded")
        {
            this->global_timebounded = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "launch_window_open_date")
        {
            this->launch_window_open_date = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->launch_window_open_date < this->launch_window_open_date_lowerBound || this->launch_window_open_date > this->launch_window_open_date_upperBound)
            {
                throw std::out_of_range("Input option launch_window_open_date is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->launch_window_open_date) + ", bounds are [" + std::to_string(this->launch_window_open_date_lowerBound) + ", " + std::to_string(this->launch_window_open_date_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "total_flight_time_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option total_flight_time_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->total_flight_time_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->total_flight_time_bounds.push_back(std::stod(linecell[entryIndex + 1]) * 86400.0);
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->total_flight_time_bounds[entryIndex] < this->total_flight_time_bounds_lowerBound[entryIndex] || this->total_flight_time_bounds[entryIndex] > this->total_flight_time_bounds_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option total_flight_time_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->total_flight_time_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->total_flight_time_bounds_lowerBound[entryIndex]) + ", " + std::to_string(this->total_flight_time_bounds_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "DLA_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option DLA_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->DLA_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->DLA_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->DLA_bounds[entryIndex] < this->DLA_bounds_lowerBound[entryIndex] || this->DLA_bounds[entryIndex] > this->DLA_bounds_upperBound[entryIndex])
               {
                   throw std::out_of_range("Input option DLA_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->DLA_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->DLA_bounds_lowerBound[entryIndex]) + ", " + std::to_string(this->DLA_bounds_upperBound[entryIndex]) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "RLA_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option RLA_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->RLA_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->RLA_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->RLA_bounds[entryIndex] < this->RLA_bounds_lowerBound || this->RLA_bounds[entryIndex] > this->RLA_bounds_upperBound)
               {
                   throw std::out_of_range("Input option RLA_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->RLA_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->RLA_bounds_lowerBound) + ", " + std::to_string(this->RLA_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "mission_type")
        {
            this->mission_type = (PhaseType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->mission_type < this->mission_type_lowerBound || this->mission_type > this->mission_type_upperBound)
            {
                throw std::out_of_range("Input option mission_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->mission_type) + ", bounds are [" + std::to_string(this->mission_type_lowerBound) + ", " + std::to_string(this->mission_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "NLP_solver_type")
        {
            this->NLP_solver_type = std::stoi(linecell[1]);
            
            //bounds check
            if (this->NLP_solver_type < this->NLP_solver_type_lowerBound || this->NLP_solver_type > this->NLP_solver_type_upperBound)
            {
                throw std::out_of_range("Input option NLP_solver_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->NLP_solver_type) + ", bounds are [" + std::to_string(this->NLP_solver_type_lowerBound) + ", " + std::to_string(this->NLP_solver_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "NLP_solver_mode")
        {
            this->NLP_solver_mode = (NLPMode) std::stoi(linecell[1]);
            
            //bounds check
            if (this->NLP_solver_mode < this->NLP_solver_mode_lowerBound || this->NLP_solver_mode > this->NLP_solver_mode_upperBound)
            {
                throw std::out_of_range("Input option NLP_solver_mode is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->NLP_solver_mode) + ", bounds are [" + std::to_string(this->NLP_solver_mode_lowerBound) + ", " + std::to_string(this->NLP_solver_mode_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "quiet_NLP")
        {
            this->quiet_NLP = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "ACE_feasible_point_finder")
        {
            this->ACE_feasible_point_finder = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "MBH_always_write_archive")
        {
            this->MBH_always_write_archive = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "MBH_archive_state_vector")
        {
            this->MBH_archive_state_vector = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "MBH_max_not_improve")
        {
            this->MBH_max_not_improve = std::stoi(linecell[1]);
            
            //bounds check
            if (this->MBH_max_not_improve < this->MBH_max_not_improve_lowerBound || this->MBH_max_not_improve > this->MBH_max_not_improve_upperBound)
            {
                throw std::out_of_range("Input option MBH_max_not_improve is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_max_not_improve) + ", bounds are [" + std::to_string(this->MBH_max_not_improve_lowerBound) + ", " + std::to_string(this->MBH_max_not_improve_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_max_trials")
        {
            this->MBH_max_trials = std::stoi(linecell[1]);
            
            //bounds check
            if (this->MBH_max_trials < this->MBH_max_trials_lowerBound || this->MBH_max_trials > this->MBH_max_trials_upperBound)
            {
                throw std::out_of_range("Input option MBH_max_trials is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_max_trials) + ", bounds are [" + std::to_string(this->MBH_max_trials_lowerBound) + ", " + std::to_string(this->MBH_max_trials_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_max_run_time")
        {
            this->MBH_max_run_time = std::stoi(linecell[1]);
            
            //bounds check
            if (this->MBH_max_run_time < this->MBH_max_run_time_lowerBound || this->MBH_max_run_time > this->MBH_max_run_time_upperBound)
            {
                throw std::out_of_range("Input option MBH_max_run_time is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_max_run_time) + ", bounds are [" + std::to_string(this->MBH_max_run_time_lowerBound) + ", " + std::to_string(this->MBH_max_run_time_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_max_step_size")
        {
            this->MBH_max_step_size = std::stod(linecell[1]);
            
            //bounds check
            if (this->MBH_max_step_size < this->MBH_max_step_size_lowerBound || this->MBH_max_step_size > this->MBH_max_step_size_upperBound)
            {
                throw std::out_of_range("Input option MBH_max_step_size is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_max_step_size) + ", bounds are [" + std::to_string(this->MBH_max_step_size_lowerBound) + ", " + std::to_string(this->MBH_max_step_size_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_hop_distribution")
        {
            this->MBH_hop_distribution = std::stoi(linecell[1]);
            
            //bounds check
            if (this->MBH_hop_distribution < this->MBH_hop_distribution_lowerBound || this->MBH_hop_distribution > this->MBH_hop_distribution_upperBound)
            {
                throw std::out_of_range("Input option MBH_hop_distribution is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_hop_distribution) + ", bounds are [" + std::to_string(this->MBH_hop_distribution_lowerBound) + ", " + std::to_string(this->MBH_hop_distribution_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_Pareto_alpha")
        {
            this->MBH_Pareto_alpha = std::stod(linecell[1]);
            
            //bounds check
            if (this->MBH_Pareto_alpha < this->MBH_Pareto_alpha_lowerBound || this->MBH_Pareto_alpha > this->MBH_Pareto_alpha_upperBound)
            {
                throw std::out_of_range("Input option MBH_Pareto_alpha is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_Pareto_alpha) + ", bounds are [" + std::to_string(this->MBH_Pareto_alpha_lowerBound) + ", " + std::to_string(this->MBH_Pareto_alpha_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_write_every_improvement")
        {
            this->MBH_write_every_improvement = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "MBH_time_hop_probability")
        {
            this->MBH_time_hop_probability = std::stod(linecell[1]);
            
            //bounds check
            if (this->MBH_time_hop_probability < this->MBH_time_hop_probability_lowerBound || this->MBH_time_hop_probability > this->MBH_time_hop_probability_upperBound)
            {
                throw std::out_of_range("Input option MBH_time_hop_probability is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_time_hop_probability) + ", bounds are [" + std::to_string(this->MBH_time_hop_probability_lowerBound) + ", " + std::to_string(this->MBH_time_hop_probability_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "snopt_feasibility_tolerance")
        {
            this->snopt_feasibility_tolerance = std::stod(linecell[1]);
            
            //bounds check
            if (this->snopt_feasibility_tolerance < this->snopt_feasibility_tolerance_lowerBound || this->snopt_feasibility_tolerance > this->snopt_feasibility_tolerance_upperBound)
            {
                throw std::out_of_range("Input option snopt_feasibility_tolerance is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->snopt_feasibility_tolerance) + ", bounds are [" + std::to_string(this->snopt_feasibility_tolerance_lowerBound) + ", " + std::to_string(this->snopt_feasibility_tolerance_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "snopt_optimality_tolerance")
        {
            this->snopt_optimality_tolerance = std::stod(linecell[1]);
            
            //bounds check
            if (this->snopt_optimality_tolerance < this->snopt_optimality_tolerance_lowerBound || this->snopt_optimality_tolerance > this->snopt_optimality_tolerance_upperBound)
            {
                throw std::out_of_range("Input option snopt_optimality_tolerance is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->snopt_optimality_tolerance) + ", bounds are [" + std::to_string(this->snopt_optimality_tolerance_lowerBound) + ", " + std::to_string(this->snopt_optimality_tolerance_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "NLP_max_step")
        {
            this->NLP_max_step = std::stod(linecell[1]);
            
            //bounds check
            if (this->NLP_max_step < this->NLP_max_step_lowerBound || this->NLP_max_step > this->NLP_max_step_upperBound)
            {
                throw std::out_of_range("Input option NLP_max_step is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->NLP_max_step) + ", bounds are [" + std::to_string(this->NLP_max_step_lowerBound) + ", " + std::to_string(this->NLP_max_step_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "snopt_major_iterations")
        {
            this->snopt_major_iterations = std::stoi(linecell[1]);
            
            //bounds check
            if (this->snopt_major_iterations < this->snopt_major_iterations_lowerBound || this->snopt_major_iterations > this->snopt_major_iterations_upperBound)
            {
                throw std::out_of_range("Input option snopt_major_iterations is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->snopt_major_iterations) + ", bounds are [" + std::to_string(this->snopt_major_iterations_lowerBound) + ", " + std::to_string(this->snopt_major_iterations_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "snopt_minor_iterations")
        {
            this->snopt_minor_iterations = std::stoi(linecell[1]);
            
            //bounds check
            if (this->snopt_minor_iterations < this->snopt_minor_iterations_lowerBound || this->snopt_minor_iterations > this->snopt_minor_iterations_upperBound)
            {
                throw std::out_of_range("Input option snopt_minor_iterations is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->snopt_minor_iterations) + ", bounds are [" + std::to_string(this->snopt_minor_iterations_lowerBound) + ", " + std::to_string(this->snopt_minor_iterations_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "snopt_max_run_time")
        {
            this->snopt_max_run_time = std::stoi(linecell[1]);
            
            //bounds check
            if (this->snopt_max_run_time < this->snopt_max_run_time_lowerBound || this->snopt_max_run_time > this->snopt_max_run_time_upperBound)
            {
                throw std::out_of_range("Input option snopt_max_run_time is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->snopt_max_run_time) + ", bounds are [" + std::to_string(this->snopt_max_run_time_lowerBound) + ", " + std::to_string(this->snopt_max_run_time_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "enable_Scalatron")
        {
            this->enable_Scalatron = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "enable_NLP_chaperone")
        {
            this->enable_NLP_chaperone = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "seed_MBH")
        {
            this->seed_MBH = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "skip_first_nlp_run")
        {
            this->skip_first_nlp_run = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "NLP_stop_on_goal_attain")
        {
            this->NLP_stop_on_goal_attain = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "NLP_objective_goal")
        {
            this->NLP_objective_goal = std::stod(linecell[1]);
            
            //bounds check
            if (this->NLP_objective_goal < this->NLP_objective_goal_lowerBound || this->NLP_objective_goal > this->NLP_objective_goal_upperBound)
            {
                throw std::out_of_range("Input option NLP_objective_goal is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->NLP_objective_goal) + ", bounds are [" + std::to_string(this->NLP_objective_goal_lowerBound) + ", " + std::to_string(this->NLP_objective_goal_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "MBH_RNG_seed")
        {
            this->MBH_RNG_seed = std::stoi(linecell[1]);
            
            //bounds check
            if (this->MBH_RNG_seed < this->MBH_RNG_seed_lowerBound || this->MBH_RNG_seed > this->MBH_RNG_seed_upperBound)
            {
                throw std::out_of_range("Input option MBH_RNG_seed is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->MBH_RNG_seed) + ", bounds are [" + std::to_string(this->MBH_RNG_seed_lowerBound) + ", " + std::to_string(this->MBH_RNG_seed_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "print_NLP_movie_frames")
        {
            this->print_NLP_movie_frames = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "quiet_basinhopping")
        {
            this->quiet_basinhopping = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "SPICE_leap_seconds_kernel")
        {
            this->SPICE_leap_seconds_kernel = linecell[1];
            return;
        }
        if (linecell[0] == "SPICE_reference_frame_kernel")
        {
            this->SPICE_reference_frame_kernel = linecell[1];
            return;
        }
        if (linecell[0] == "universe_folder")
        {
            this->universe_folder = linecell[1];
            return;
        }
        if (linecell[0] == "ephemeris_source")
        {
            this->ephemeris_source = std::stoi(linecell[1]);
            
            //bounds check
            if (this->ephemeris_source < this->ephemeris_source_lowerBound || this->ephemeris_source > this->ephemeris_source_upperBound)
            {
                throw std::out_of_range("Input option ephemeris_source is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ephemeris_source) + ", bounds are [" + std::to_string(this->ephemeris_source_lowerBound) + ", " + std::to_string(this->ephemeris_source_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "SplineEphem_points_per_period")
        {
            this->SplineEphem_points_per_period = std::stoi(linecell[1]);
            
            //bounds check
            if (this->SplineEphem_points_per_period < this->SplineEphem_points_per_period_lowerBound || this->SplineEphem_points_per_period > this->SplineEphem_points_per_period_upperBound)
            {
                throw std::out_of_range("Input option SplineEphem_points_per_period is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->SplineEphem_points_per_period) + ", bounds are [" + std::to_string(this->SplineEphem_points_per_period_lowerBound) + ", " + std::to_string(this->SplineEphem_points_per_period_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "SplineEphem_non_central_body_sun_points_per_period")
        {
            this->SplineEphem_non_central_body_sun_points_per_period = std::stoi(linecell[1]);
            
            //bounds check
            if (this->SplineEphem_non_central_body_sun_points_per_period < this->SplineEphem_non_central_body_sun_points_per_period_lowerBound || this->SplineEphem_non_central_body_sun_points_per_period > this->SplineEphem_non_central_body_sun_points_per_period_upperBound)
            {
                throw std::out_of_range("Input option SplineEphem_non_central_body_sun_points_per_period is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->SplineEphem_non_central_body_sun_points_per_period) + ", bounds are [" + std::to_string(this->SplineEphem_non_central_body_sun_points_per_period_lowerBound) + ", " + std::to_string(this->SplineEphem_non_central_body_sun_points_per_period_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "SplineEphem_truncate_ephemeris_at_maximum_mission_epoch")
        {
            this->SplineEphem_truncate_ephemeris_at_maximum_mission_epoch = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "earliestPossibleEpoch")
        {
            this->earliestPossibleEpoch = std::stod(linecell[1]);
            
            //bounds check
            if (this->earliestPossibleEpoch < this->earliestPossibleEpoch_lowerBound || this->earliestPossibleEpoch > this->earliestPossibleEpoch_upperBound)
            {
                throw std::out_of_range("Input option earliestPossibleEpoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->earliestPossibleEpoch) + ", bounds are [" + std::to_string(this->earliestPossibleEpoch_lowerBound) + ", " + std::to_string(this->earliestPossibleEpoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "latestPossibleEpoch")
        {
            this->latestPossibleEpoch = std::stod(linecell[1]);
            
            //bounds check
            if (this->latestPossibleEpoch < this->latestPossibleEpoch_lowerBound || this->latestPossibleEpoch > this->latestPossibleEpoch_upperBound)
            {
                throw std::out_of_range("Input option latestPossibleEpoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->latestPossibleEpoch) + ", bounds are [" + std::to_string(this->latestPossibleEpoch_lowerBound) + ", " + std::to_string(this->latestPossibleEpoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "propagatorType")
        {
            this->propagatorType = (PropagatorType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->propagatorType < this->propagatorType_lowerBound || this->propagatorType > this->propagatorType_upperBound)
            {
                throw std::out_of_range("Input option propagatorType is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->propagatorType) + ", bounds are [" + std::to_string(this->propagatorType_lowerBound) + ", " + std::to_string(this->propagatorType_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "integratorType")
        {
            this->integratorType = (IntegratorType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->integratorType < this->integratorType_lowerBound || this->integratorType > this->integratorType_upperBound)
            {
                throw std::out_of_range("Input option integratorType is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->integratorType) + ", bounds are [" + std::to_string(this->integratorType_lowerBound) + ", " + std::to_string(this->integratorType_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "integrator_tolerance")
        {
            this->integrator_tolerance = std::stod(linecell[1]);
            
            //bounds check
            if (this->integrator_tolerance < this->integrator_tolerance_lowerBound || this->integrator_tolerance > this->integrator_tolerance_upperBound)
            {
                throw std::out_of_range("Input option integrator_tolerance is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->integrator_tolerance) + ", bounds are [" + std::to_string(this->integrator_tolerance_lowerBound) + ", " + std::to_string(this->integrator_tolerance_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "integration_time_step_size")
        {
            this->integration_time_step_size = std::stod(linecell[1]);
            
            //bounds check
            if (this->integration_time_step_size < this->integration_time_step_size_lowerBound || this->integration_time_step_size > this->integration_time_step_size_upperBound)
            {
                throw std::out_of_range("Input option integration_time_step_size is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->integration_time_step_size) + ", bounds are [" + std::to_string(this->integration_time_step_size_lowerBound) + ", " + std::to_string(this->integration_time_step_size_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "num_timesteps")
        {
            this->num_timesteps = std::stoi(linecell[1]);
            
            //bounds check
            if (this->num_timesteps < this->num_timesteps_lowerBound || this->num_timesteps > this->num_timesteps_upperBound)
            {
                throw std::out_of_range("Input option num_timesteps is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->num_timesteps) + ", bounds are [" + std::to_string(this->num_timesteps_lowerBound) + ", " + std::to_string(this->num_timesteps_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "spiral_segments")
        {
            this->spiral_segments = std::stoi(linecell[1]);
            
            //bounds check
            if (this->spiral_segments < this->spiral_segments_lowerBound || this->spiral_segments > this->spiral_segments_upperBound)
            {
                throw std::out_of_range("Input option spiral_segments is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spiral_segments) + ", bounds are [" + std::to_string(this->spiral_segments_lowerBound) + ", " + std::to_string(this->spiral_segments_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "allow_initial_mass_to_vary")
        {
            this->allow_initial_mass_to_vary = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "maximum_mass")
        {
            this->maximum_mass = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_mass < this->maximum_mass_lowerBound || this->maximum_mass > this->maximum_mass_upperBound)
            {
                throw std::out_of_range("Input option maximum_mass is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_mass) + ", bounds are [" + std::to_string(this->maximum_mass_lowerBound) + ", " + std::to_string(this->maximum_mass_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "IspLT")
        {
            this->IspLT = std::stod(linecell[1]);
            
            //bounds check
            if (this->IspLT < this->IspLT_lowerBound || this->IspLT > this->IspLT_upperBound)
            {
                throw std::out_of_range("Input option IspLT is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->IspLT) + ", bounds are [" + std::to_string(this->IspLT_lowerBound) + ", " + std::to_string(this->IspLT_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "IspLT_minimum")
        {
            this->IspLT_minimum = std::stod(linecell[1]);
            
            //bounds check
            if (this->IspLT_minimum < this->IspLT_minimum_lowerBound || this->IspLT_minimum > this->IspLT_minimum_upperBound)
            {
                throw std::out_of_range("Input option IspLT_minimum is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->IspLT_minimum) + ", bounds are [" + std::to_string(this->IspLT_minimum_lowerBound) + ", " + std::to_string(this->IspLT_minimum_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "IspChem")
        {
            this->IspChem = std::stod(linecell[1]);
            
            //bounds check
            if (this->IspChem < this->IspChem_lowerBound || this->IspChem > this->IspChem_upperBound)
            {
                throw std::out_of_range("Input option IspChem is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->IspChem) + ", bounds are [" + std::to_string(this->IspChem_lowerBound) + ", " + std::to_string(this->IspChem_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "Thrust")
        {
            this->Thrust = std::stod(linecell[1]);
            
            //bounds check
            if (this->Thrust < this->Thrust_lowerBound || this->Thrust > this->Thrust_upperBound)
            {
                throw std::out_of_range("Input option Thrust is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->Thrust) + ", bounds are [" + std::to_string(this->Thrust_lowerBound) + ", " + std::to_string(this->Thrust_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "LV_margin")
        {
            this->LV_margin = std::stod(linecell[1]);
            
            //bounds check
            if (this->LV_margin < this->LV_margin_lowerBound || this->LV_margin > this->LV_margin_upperBound)
            {
                throw std::out_of_range("Input option LV_margin is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->LV_margin) + ", bounds are [" + std::to_string(this->LV_margin_lowerBound) + ", " + std::to_string(this->LV_margin_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "LV_adapter_mass")
        {
            this->LV_adapter_mass = std::stod(linecell[1]);
            
            //bounds check
            if (this->LV_adapter_mass < this->LV_adapter_mass_lowerBound || this->LV_adapter_mass > this->LV_adapter_mass_upperBound)
            {
                throw std::out_of_range("Input option LV_adapter_mass is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->LV_adapter_mass) + ", bounds are [" + std::to_string(this->LV_adapter_mass_lowerBound) + ", " + std::to_string(this->LV_adapter_mass_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "engine_type")
        {
            this->engine_type = std::stoi(linecell[1]);
            
            //bounds check
            if (this->engine_type < this->engine_type_lowerBound || this->engine_type > this->engine_type_upperBound)
            {
                throw std::out_of_range("Input option engine_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->engine_type) + ", bounds are [" + std::to_string(this->engine_type_lowerBound) + ", " + std::to_string(this->engine_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "number_of_electric_propulsion_systems")
        {
            this->number_of_electric_propulsion_systems = std::stoi(linecell[1]);
            
            //bounds check
            if (this->number_of_electric_propulsion_systems < this->number_of_electric_propulsion_systems_lowerBound || this->number_of_electric_propulsion_systems > this->number_of_electric_propulsion_systems_upperBound)
            {
                throw std::out_of_range("Input option number_of_electric_propulsion_systems is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->number_of_electric_propulsion_systems) + ", bounds are [" + std::to_string(this->number_of_electric_propulsion_systems_lowerBound) + ", " + std::to_string(this->number_of_electric_propulsion_systems_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "engine_duty_cycle")
        {
            this->engine_duty_cycle = std::stod(linecell[1]);
            
            //bounds check
            if (this->engine_duty_cycle < this->engine_duty_cycle_lowerBound || this->engine_duty_cycle > this->engine_duty_cycle_upperBound)
            {
                throw std::out_of_range("Input option engine_duty_cycle is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->engine_duty_cycle) + ", bounds are [" + std::to_string(this->engine_duty_cycle_lowerBound) + ", " + std::to_string(this->engine_duty_cycle_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "duty_cycle_type")
        {
            this->duty_cycle_type = (DutyCycleType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->duty_cycle_type < this->duty_cycle_type_lowerBound || this->duty_cycle_type > this->duty_cycle_type_upperBound)
            {
                throw std::out_of_range("Input option duty_cycle_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->duty_cycle_type) + ", bounds are [" + std::to_string(this->duty_cycle_type_lowerBound) + ", " + std::to_string(this->duty_cycle_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "thrust_scale_factor")
        {
            this->thrust_scale_factor = std::stod(linecell[1]);
            
            //bounds check
            if (this->thrust_scale_factor < this->thrust_scale_factor_lowerBound || this->thrust_scale_factor > this->thrust_scale_factor_upperBound)
            {
                throw std::out_of_range("Input option thrust_scale_factor is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->thrust_scale_factor) + ", bounds are [" + std::to_string(this->thrust_scale_factor_lowerBound) + ", " + std::to_string(this->thrust_scale_factor_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "power_at_1_AU")
        {
            this->power_at_1_AU = std::stod(linecell[1]);
            
            //bounds check
            if (this->power_at_1_AU < this->power_at_1_AU_lowerBound || this->power_at_1_AU > this->power_at_1_AU_upperBound)
            {
                throw std::out_of_range("Input option power_at_1_AU is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_at_1_AU) + ", bounds are [" + std::to_string(this->power_at_1_AU_lowerBound) + ", " + std::to_string(this->power_at_1_AU_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "power_source_type")
        {
            this->power_source_type = (SpacecraftPowerSupplyType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->power_source_type < this->power_source_type_lowerBound || this->power_source_type > this->power_source_type_upperBound)
            {
                throw std::out_of_range("Input option power_source_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_source_type) + ", bounds are [" + std::to_string(this->power_source_type_lowerBound) + ", " + std::to_string(this->power_source_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "solar_power_model_type")
        {
            this->solar_power_model_type = (SpacecraftPowerSupplyCurveType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->solar_power_model_type < this->solar_power_model_type_lowerBound || this->solar_power_model_type > this->solar_power_model_type_upperBound)
            {
                throw std::out_of_range("Input option solar_power_model_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->solar_power_model_type) + ", bounds are [" + std::to_string(this->solar_power_model_type_lowerBound) + ", " + std::to_string(this->solar_power_model_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "solar_power_gamma")
        {
            if (linecell.size() - 1 != 7)
            {
                throw std::invalid_argument("Input option solar_power_gamma has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 7 arguments.");
            }
            
            this->solar_power_gamma.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->solar_power_gamma.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->solar_power_gamma[entryIndex] < this->solar_power_gamma_lowerBound || this->solar_power_gamma[entryIndex] > this->solar_power_gamma_upperBound)
               {
                   throw std::out_of_range("Input option solar_power_gamma[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->solar_power_gamma[entryIndex]) + ", bounds are [" + std::to_string(this->solar_power_gamma_lowerBound) + ", " + std::to_string(this->solar_power_gamma_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "power_margin")
        {
            this->power_margin = std::stod(linecell[1]);
            
            //bounds check
            if (this->power_margin < this->power_margin_lowerBound || this->power_margin > this->power_margin_upperBound)
            {
                throw std::out_of_range("Input option power_margin is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_margin) + ", bounds are [" + std::to_string(this->power_margin_lowerBound) + ", " + std::to_string(this->power_margin_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "power_decay_rate")
        {
            this->power_decay_rate = std::stod(linecell[1]);
            
            //bounds check
            if (this->power_decay_rate < this->power_decay_rate_lowerBound || this->power_decay_rate > this->power_decay_rate_upperBound)
            {
                throw std::out_of_range("Input option power_decay_rate is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_decay_rate) + ", bounds are [" + std::to_string(this->power_decay_rate_lowerBound) + ", " + std::to_string(this->power_decay_rate_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "power_decay_type")
        {
            this->power_decay_type = std::stoi(linecell[1]);
            
            //bounds check
            if (this->power_decay_type < this->power_decay_type_lowerBound || this->power_decay_type > this->power_decay_type_upperBound)
            {
                throw std::out_of_range("Input option power_decay_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_decay_type) + ", bounds are [" + std::to_string(this->power_decay_type_lowerBound) + ", " + std::to_string(this->power_decay_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "decay_coefficients")
        {
            if (linecell.size() - 1 != 4)
            {
                throw std::invalid_argument("Input option decay_coefficients has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 4 arguments.");
            }
            
            this->decay_coefficients.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->decay_coefficients.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->decay_coefficients[entryIndex] < this->decay_coefficients_lowerBound || this->decay_coefficients[entryIndex] > this->decay_coefficients_upperBound)
               {
                   throw std::out_of_range("Input option decay_coefficients[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->decay_coefficients[entryIndex]) + ", bounds are [" + std::to_string(this->decay_coefficients_lowerBound) + ", " + std::to_string(this->decay_coefficients_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "power_system_decay_reference_epoch")
        {
            this->power_system_decay_reference_epoch = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->power_system_decay_reference_epoch < this->power_system_decay_reference_epoch_lowerBound || this->power_system_decay_reference_epoch > this->power_system_decay_reference_epoch_upperBound)
            {
                throw std::out_of_range("Input option power_system_decay_reference_epoch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->power_system_decay_reference_epoch) + ", bounds are [" + std::to_string(this->power_system_decay_reference_epoch_lowerBound) + ", " + std::to_string(this->power_system_decay_reference_epoch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "throttle_sharpness")
        {
            this->throttle_sharpness = std::stod(linecell[1]);
            
            //bounds check
            if (this->throttle_sharpness < this->throttle_sharpness_lowerBound || this->throttle_sharpness > this->throttle_sharpness_upperBound)
            {
                throw std::out_of_range("Input option throttle_sharpness is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->throttle_sharpness) + ", bounds are [" + std::to_string(this->throttle_sharpness_lowerBound) + ", " + std::to_string(this->throttle_sharpness_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "throttle_logic_mode")
        {
            this->throttle_logic_mode = (ThrottleLogic) std::stoi(linecell[1]);
            
            //bounds check
            if (this->throttle_logic_mode < this->throttle_logic_mode_lowerBound || this->throttle_logic_mode > this->throttle_logic_mode_upperBound)
            {
                throw std::out_of_range("Input option throttle_logic_mode is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->throttle_logic_mode) + ", bounds are [" + std::to_string(this->throttle_logic_mode_lowerBound) + ", " + std::to_string(this->throttle_logic_mode_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "spacecraft_power_coefficients")
        {
            if (linecell.size() - 1 != 3)
            {
                throw std::invalid_argument("Input option spacecraft_power_coefficients has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 3 arguments.");
            }
            
            this->spacecraft_power_coefficients.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->spacecraft_power_coefficients.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->spacecraft_power_coefficients[entryIndex] < this->spacecraft_power_coefficients_lowerBound || this->spacecraft_power_coefficients[entryIndex] > this->spacecraft_power_coefficients_upperBound)
               {
                   throw std::out_of_range("Input option spacecraft_power_coefficients[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spacecraft_power_coefficients[entryIndex]) + ", bounds are [" + std::to_string(this->spacecraft_power_coefficients_lowerBound) + ", " + std::to_string(this->spacecraft_power_coefficients_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "engine_input_thrust_coefficients")
        {
            if (linecell.size() - 1 != 7)
            {
                throw std::invalid_argument("Input option engine_input_thrust_coefficients has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 7 arguments.");
            }
            
            this->engine_input_thrust_coefficients.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->engine_input_thrust_coefficients.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->engine_input_thrust_coefficients[entryIndex] < this->engine_input_thrust_coefficients_lowerBound || this->engine_input_thrust_coefficients[entryIndex] > this->engine_input_thrust_coefficients_upperBound)
               {
                   throw std::out_of_range("Input option engine_input_thrust_coefficients[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->engine_input_thrust_coefficients[entryIndex]) + ", bounds are [" + std::to_string(this->engine_input_thrust_coefficients_lowerBound) + ", " + std::to_string(this->engine_input_thrust_coefficients_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "engine_input_mass_flow_rate_coefficients")
        {
            if (linecell.size() - 1 != 7)
            {
                throw std::invalid_argument("Input option engine_input_mass_flow_rate_coefficients has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 7 arguments.");
            }
            
            this->engine_input_mass_flow_rate_coefficients.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->engine_input_mass_flow_rate_coefficients.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->engine_input_mass_flow_rate_coefficients[entryIndex] < this->engine_input_mass_flow_rate_coefficients_lowerBound || this->engine_input_mass_flow_rate_coefficients[entryIndex] > this->engine_input_mass_flow_rate_coefficients_upperBound)
               {
                   throw std::out_of_range("Input option engine_input_mass_flow_rate_coefficients[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->engine_input_mass_flow_rate_coefficients[entryIndex]) + ", bounds are [" + std::to_string(this->engine_input_mass_flow_rate_coefficients_lowerBound) + ", " + std::to_string(this->engine_input_mass_flow_rate_coefficients_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "engine_input_power_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option engine_input_power_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->engine_input_power_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->engine_input_power_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->engine_input_power_bounds[entryIndex] < this->engine_input_power_bounds_lowerBound || this->engine_input_power_bounds[entryIndex] > this->engine_input_power_bounds_upperBound)
               {
                   throw std::out_of_range("Input option engine_input_power_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->engine_input_power_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->engine_input_power_bounds_lowerBound) + ", " + std::to_string(this->engine_input_power_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "user_defined_engine_efficiency")
        {
            this->user_defined_engine_efficiency = std::stod(linecell[1]);
            
            //bounds check
            if (this->user_defined_engine_efficiency < this->user_defined_engine_efficiency_lowerBound || this->user_defined_engine_efficiency > this->user_defined_engine_efficiency_upperBound)
            {
                throw std::out_of_range("Input option user_defined_engine_efficiency is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->user_defined_engine_efficiency) + ", bounds are [" + std::to_string(this->user_defined_engine_efficiency_lowerBound) + ", " + std::to_string(this->user_defined_engine_efficiency_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "spacecraft_power_model_type")
        {
            this->spacecraft_power_model_type = (SpacecraftBusPowerType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->spacecraft_power_model_type < this->spacecraft_power_model_type_lowerBound || this->spacecraft_power_model_type > this->spacecraft_power_model_type_upperBound)
            {
                throw std::out_of_range("Input option spacecraft_power_model_type is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spacecraft_power_model_type) + ", bounds are [" + std::to_string(this->spacecraft_power_model_type_lowerBound) + ", " + std::to_string(this->spacecraft_power_model_type_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "TCM_Isp")
        {
            this->TCM_Isp = std::stod(linecell[1]);
            
            //bounds check
            if (this->TCM_Isp < this->TCM_Isp_lowerBound || this->TCM_Isp > this->TCM_Isp_upperBound)
            {
                throw std::out_of_range("Input option TCM_Isp is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->TCM_Isp) + ", bounds are [" + std::to_string(this->TCM_Isp_lowerBound) + ", " + std::to_string(this->TCM_Isp_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "TCM_post_launch")
        {
            this->TCM_post_launch = std::stod(linecell[1]);
            
            //bounds check
            if (this->TCM_post_launch < this->TCM_post_launch_lowerBound || this->TCM_post_launch > this->TCM_post_launch_upperBound)
            {
                throw std::out_of_range("Input option TCM_post_launch is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->TCM_post_launch) + ", bounds are [" + std::to_string(this->TCM_post_launch_lowerBound) + ", " + std::to_string(this->TCM_post_launch_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "TCM_pre_flyby")
        {
            this->TCM_pre_flyby = std::stod(linecell[1]);
            
            //bounds check
            if (this->TCM_pre_flyby < this->TCM_pre_flyby_lowerBound || this->TCM_pre_flyby > this->TCM_pre_flyby_upperBound)
            {
                throw std::out_of_range("Input option TCM_pre_flyby is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->TCM_pre_flyby) + ", bounds are [" + std::to_string(this->TCM_pre_flyby_lowerBound) + ", " + std::to_string(this->TCM_pre_flyby_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "TCM_maneuver_fraction")
        {
            this->TCM_maneuver_fraction = std::stod(linecell[1]);
            
            //bounds check
            if (this->TCM_maneuver_fraction < this->TCM_maneuver_fraction_lowerBound || this->TCM_maneuver_fraction > this->TCM_maneuver_fraction_upperBound)
            {
                throw std::out_of_range("Input option TCM_maneuver_fraction is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->TCM_maneuver_fraction) + ", bounds are [" + std::to_string(this->TCM_maneuver_fraction_lowerBound) + ", " + std::to_string(this->TCM_maneuver_fraction_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "trackACS")
        {
            this->trackACS = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "ACS_kg_per_day")
        {
            this->ACS_kg_per_day = std::stod(linecell[1]);
            
            //bounds check
            if (this->ACS_kg_per_day < this->ACS_kg_per_day_lowerBound || this->ACS_kg_per_day > this->ACS_kg_per_day_upperBound)
            {
                throw std::out_of_range("Input option ACS_kg_per_day is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ACS_kg_per_day) + ", bounds are [" + std::to_string(this->ACS_kg_per_day_lowerBound) + ", " + std::to_string(this->ACS_kg_per_day_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "final_mass_constraint_bounds")
        {
            if (linecell.size() - 1 != 2)
            {
                throw std::invalid_argument("Input option final_mass_constraint_bounds has been passed " + std::to_string(linecell.size() - 1) + " arguments but requires 2 arguments.");
            }
            
            this->final_mass_constraint_bounds.clear();
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
                this->final_mass_constraint_bounds.push_back(std::stod(linecell[entryIndex + 1]));
            }
            
            //bounds check
            for (size_t entryIndex = 0; entryIndex < linecell.size() - 1; ++entryIndex)
            {
               if (this->final_mass_constraint_bounds[entryIndex] < this->final_mass_constraint_bounds_lowerBound || this->final_mass_constraint_bounds[entryIndex] > this->final_mass_constraint_bounds_upperBound)
               {
                   throw std::out_of_range("Input option final_mass_constraint_bounds[" + std::to_string(entryIndex) + "] is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->final_mass_constraint_bounds[entryIndex]) + ", bounds are [" + std::to_string(this->final_mass_constraint_bounds_lowerBound) + ", " + std::to_string(this->final_mass_constraint_bounds_upperBound) + "].");
               }
            }
            return;
        }
        if (linecell[0] == "constrain_final_mass")
        {
            this->constrain_final_mass = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "constrain_dry_mass")
        {
            this->constrain_dry_mass = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "enable_electric_propellant_tank_constraint")
        {
            this->enable_electric_propellant_tank_constraint = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "maximum_electric_propellant")
        {
            this->maximum_electric_propellant = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_electric_propellant < this->maximum_electric_propellant_lowerBound || this->maximum_electric_propellant > this->maximum_electric_propellant_upperBound)
            {
                throw std::out_of_range("Input option maximum_electric_propellant is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_electric_propellant) + ", bounds are [" + std::to_string(this->maximum_electric_propellant_lowerBound) + ", " + std::to_string(this->maximum_electric_propellant_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "electric_propellant_margin")
        {
            this->electric_propellant_margin = std::stod(linecell[1]);
            
            //bounds check
            if (this->electric_propellant_margin < this->electric_propellant_margin_lowerBound || this->electric_propellant_margin > this->electric_propellant_margin_upperBound)
            {
                throw std::out_of_range("Input option electric_propellant_margin is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->electric_propellant_margin) + ", bounds are [" + std::to_string(this->electric_propellant_margin_lowerBound) + ", " + std::to_string(this->electric_propellant_margin_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "enable_chemical_propellant_tank_constraint")
        {
            this->enable_chemical_propellant_tank_constraint = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "maximum_chemical_fuel")
        {
            this->maximum_chemical_fuel = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_chemical_fuel < this->maximum_chemical_fuel_lowerBound || this->maximum_chemical_fuel > this->maximum_chemical_fuel_upperBound)
            {
                throw std::out_of_range("Input option maximum_chemical_fuel is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_chemical_fuel) + ", bounds are [" + std::to_string(this->maximum_chemical_fuel_lowerBound) + ", " + std::to_string(this->maximum_chemical_fuel_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "maximum_chemical_oxidizer")
        {
            this->maximum_chemical_oxidizer = std::stod(linecell[1]);
            
            //bounds check
            if (this->maximum_chemical_oxidizer < this->maximum_chemical_oxidizer_lowerBound || this->maximum_chemical_oxidizer > this->maximum_chemical_oxidizer_upperBound)
            {
                throw std::out_of_range("Input option maximum_chemical_oxidizer is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->maximum_chemical_oxidizer) + ", bounds are [" + std::to_string(this->maximum_chemical_oxidizer_lowerBound) + ", " + std::to_string(this->maximum_chemical_oxidizer_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "bipropellant_mixture_ratio")
        {
            this->bipropellant_mixture_ratio = std::stod(linecell[1]);
            
            //bounds check
            if (this->bipropellant_mixture_ratio < this->bipropellant_mixture_ratio_lowerBound || this->bipropellant_mixture_ratio > this->bipropellant_mixture_ratio_upperBound)
            {
                throw std::out_of_range("Input option bipropellant_mixture_ratio is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->bipropellant_mixture_ratio) + ", bounds are [" + std::to_string(this->bipropellant_mixture_ratio_lowerBound) + ", " + std::to_string(this->bipropellant_mixture_ratio_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "chemical_propellant_margin")
        {
            this->chemical_propellant_margin = std::stod(linecell[1]);
            
            //bounds check
            if (this->chemical_propellant_margin < this->chemical_propellant_margin_lowerBound || this->chemical_propellant_margin > this->chemical_propellant_margin_upperBound)
            {
                throw std::out_of_range("Input option chemical_propellant_margin is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->chemical_propellant_margin) + ", bounds are [" + std::to_string(this->chemical_propellant_margin_lowerBound) + ", " + std::to_string(this->chemical_propellant_margin_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "SpacecraftModelInput")
        {
            this->SpacecraftModelInput = (SpacecraftModelInputType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->SpacecraftModelInput < this->SpacecraftModelInput_lowerBound || this->SpacecraftModelInput > this->SpacecraftModelInput_upperBound)
            {
                throw std::out_of_range("Input option SpacecraftModelInput is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->SpacecraftModelInput) + ", bounds are [" + std::to_string(this->SpacecraftModelInput_lowerBound) + ", " + std::to_string(this->SpacecraftModelInput_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "HardwarePath")
        {
            this->HardwarePath = linecell[1];
            return;
        }
        if (linecell[0] == "ThrottleTableFile")
        {
            this->ThrottleTableFile = linecell[1];
            return;
        }
        if (linecell[0] == "LaunchVehicleLibraryFile")
        {
            this->LaunchVehicleLibraryFile = linecell[1];
            return;
        }
        if (linecell[0] == "PowerSystemsLibraryFile")
        {
            this->PowerSystemsLibraryFile = linecell[1];
            return;
        }
        if (linecell[0] == "PropulsionSystemsLibraryFile")
        {
            this->PropulsionSystemsLibraryFile = linecell[1];
            return;
        }
        if (linecell[0] == "SpacecraftOptionsFile")
        {
            this->SpacecraftOptionsFile = linecell[1];
            return;
        }
        if (linecell[0] == "LaunchVehicleKey")
        {
            this->LaunchVehicleKey = linecell[1];
            return;
        }
        if (linecell[0] == "PowerSystemKey")
        {
            this->PowerSystemKey = linecell[1];
            return;
        }
        if (linecell[0] == "ElectricPropulsionSystemKey")
        {
            this->ElectricPropulsionSystemKey = linecell[1];
            return;
        }
        if (linecell[0] == "ChemicalPropulsionSystemKey")
        {
            this->ChemicalPropulsionSystemKey = linecell[1];
            return;
        }
        if (linecell[0] == "perturb_SRP")
        {
            this->perturb_SRP = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "perturb_thirdbody")
        {
            this->perturb_thirdbody = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "perturb_J2")
        {
            this->perturb_J2 = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "spacecraft_area")
        {
            this->spacecraft_area = std::stod(linecell[1]);
            
            //bounds check
            if (this->spacecraft_area < this->spacecraft_area_lowerBound || this->spacecraft_area > this->spacecraft_area_upperBound)
            {
                throw std::out_of_range("Input option spacecraft_area is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spacecraft_area) + ", bounds are [" + std::to_string(this->spacecraft_area_lowerBound) + ", " + std::to_string(this->spacecraft_area_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "coefficient_of_reflectivity")
        {
            this->coefficient_of_reflectivity = std::stod(linecell[1]);
            
            //bounds check
            if (this->coefficient_of_reflectivity < this->coefficient_of_reflectivity_lowerBound || this->coefficient_of_reflectivity > this->coefficient_of_reflectivity_upperBound)
            {
                throw std::out_of_range("Input option coefficient_of_reflectivity is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->coefficient_of_reflectivity) + ", bounds are [" + std::to_string(this->coefficient_of_reflectivity_lowerBound) + ", " + std::to_string(this->coefficient_of_reflectivity_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "solar_percentage")
        {
            this->solar_percentage = (double ) std::stoi(linecell[1]);
            
            //bounds check
            if (this->solar_percentage < this->solar_percentage_lowerBound || this->solar_percentage > this->solar_percentage_upperBound)
            {
                throw std::out_of_range("Input option solar_percentage is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->solar_percentage) + ", bounds are [" + std::to_string(this->solar_percentage_lowerBound) + ", " + std::to_string(this->solar_percentage_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "solar_flux")
        {
            this->solar_flux = std::stod(linecell[1]);
            
            //bounds check
            if (this->solar_flux < this->solar_flux_lowerBound || this->solar_flux > this->solar_flux_upperBound)
            {
                throw std::out_of_range("Input option solar_flux is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->solar_flux) + ", bounds are [" + std::to_string(this->solar_flux_lowerBound) + ", " + std::to_string(this->solar_flux_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "speed_of_light_vac")
        {
            this->speed_of_light_vac = std::stod(linecell[1]);
            
            //bounds check
            if (this->speed_of_light_vac < this->speed_of_light_vac_lowerBound || this->speed_of_light_vac > this->speed_of_light_vac_upperBound)
            {
                throw std::out_of_range("Input option speed_of_light_vac is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->speed_of_light_vac) + ", bounds are [" + std::to_string(this->speed_of_light_vac_lowerBound) + ", " + std::to_string(this->speed_of_light_vac_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "forced_post_launch_coast")
        {
            this->forced_post_launch_coast = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->forced_post_launch_coast < this->forced_post_launch_coast_lowerBound || this->forced_post_launch_coast > this->forced_post_launch_coast_upperBound)
            {
                throw std::out_of_range("Input option forced_post_launch_coast is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forced_post_launch_coast) + ", bounds are [" + std::to_string(this->forced_post_launch_coast_lowerBound) + ", " + std::to_string(this->forced_post_launch_coast_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "forced_pre_flyby_coast")
        {
            this->forced_pre_flyby_coast = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->forced_pre_flyby_coast < this->forced_pre_flyby_coast_lowerBound || this->forced_pre_flyby_coast > this->forced_pre_flyby_coast_upperBound)
            {
                throw std::out_of_range("Input option forced_pre_flyby_coast is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forced_pre_flyby_coast) + ", bounds are [" + std::to_string(this->forced_pre_flyby_coast_lowerBound) + ", " + std::to_string(this->forced_pre_flyby_coast_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "forced_post_flyby_coast")
        {
            this->forced_post_flyby_coast = std::stod(linecell[1]) * 86400.0;
            
            //bounds check
            if (this->forced_post_flyby_coast < this->forced_post_flyby_coast_lowerBound || this->forced_post_flyby_coast > this->forced_post_flyby_coast_upperBound)
            {
                throw std::out_of_range("Input option forced_post_flyby_coast is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forced_post_flyby_coast) + ", bounds are [" + std::to_string(this->forced_post_flyby_coast_lowerBound) + ", " + std::to_string(this->forced_post_flyby_coast_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "waypoint_file_path")
        {
            this->waypoint_file_path = linecell[1];
            return;
        }
        if (linecell[0] == "covariance_file_path")
        {
            this->covariance_file_path = linecell[1];
            return;
        }
        if (linecell[0] == "ParallelShootingStateRepresentation")
        {
            this->ParallelShootingStateRepresentation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->ParallelShootingStateRepresentation < this->ParallelShootingStateRepresentation_lowerBound || this->ParallelShootingStateRepresentation > this->ParallelShootingStateRepresentation_upperBound)
            {
                throw std::out_of_range("Input option ParallelShootingStateRepresentation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ParallelShootingStateRepresentation) + ", bounds are [" + std::to_string(this->ParallelShootingStateRepresentation_lowerBound) + ", " + std::to_string(this->ParallelShootingStateRepresentation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "PeriapseBoundaryStateRepresentation")
        {
            this->PeriapseBoundaryStateRepresentation = (StateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->PeriapseBoundaryStateRepresentation < this->PeriapseBoundaryStateRepresentation_lowerBound || this->PeriapseBoundaryStateRepresentation > this->PeriapseBoundaryStateRepresentation_upperBound)
            {
                throw std::out_of_range("Input option PeriapseBoundaryStateRepresentation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->PeriapseBoundaryStateRepresentation) + ", bounds are [" + std::to_string(this->PeriapseBoundaryStateRepresentation_lowerBound) + ", " + std::to_string(this->PeriapseBoundaryStateRepresentation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "ParallelShootingConstraintStateRepresentation")
        {
            this->ParallelShootingConstraintStateRepresentation = (ConstraintStateRepresentation) std::stoi(linecell[1]);
            
            //bounds check
            if (this->ParallelShootingConstraintStateRepresentation < this->ParallelShootingConstraintStateRepresentation_lowerBound || this->ParallelShootingConstraintStateRepresentation > this->ParallelShootingConstraintStateRepresentation_upperBound)
            {
                throw std::out_of_range("Input option ParallelShootingConstraintStateRepresentation is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->ParallelShootingConstraintStateRepresentation) + ", bounds are [" + std::to_string(this->ParallelShootingConstraintStateRepresentation_lowerBound) + ", " + std::to_string(this->ParallelShootingConstraintStateRepresentation_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "print_only_non_default_options")
        {
            this->print_only_non_default_options = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "output_file_frame")
        {
            this->output_file_frame = (ReferenceFrame) std::stoi(linecell[1]);
            
            //bounds check
            if (this->output_file_frame < this->output_file_frame_lowerBound || this->output_file_frame > this->output_file_frame_upperBound)
            {
                throw std::out_of_range("Input option output_file_frame is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->output_file_frame) + ", bounds are [" + std::to_string(this->output_file_frame_lowerBound) + ", " + std::to_string(this->output_file_frame_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_default_output_file_name")
        {
            this->override_default_output_file_name = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "forced_output_file_name")
        {
            this->forced_output_file_name = linecell[1];
            return;
        }
        if (linecell[0] == "output_dormant_journeys")
        {
            this->output_dormant_journeys = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "post_mission_wait_time")
        {
            this->post_mission_wait_time = std::stod(linecell[1]);
            
            //bounds check
            if (this->post_mission_wait_time < this->post_mission_wait_time_lowerBound || this->post_mission_wait_time > this->post_mission_wait_time_upperBound)
            {
                throw std::out_of_range("Input option post_mission_wait_time is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->post_mission_wait_time) + ", bounds are [" + std::to_string(this->post_mission_wait_time_lowerBound) + ", " + std::to_string(this->post_mission_wait_time_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "override_working_directory")
        {
            this->override_working_directory = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "forced_working_directory")
        {
            this->forced_working_directory = linecell[1];
            return;
        }
        if (linecell[0] == "override_mission_subfolder")
        {
            this->override_mission_subfolder = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "forced_mission_subfolder")
        {
            this->forced_mission_subfolder = linecell[1];
            return;
        }
        if (linecell[0] == "short_output_file_names")
        {
            this->short_output_file_names = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "generate_forward_integrated_ephemeris")
        {
            this->generate_forward_integrated_ephemeris = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "forward_integrated_ephemeris_central_body_SPICE_ID")
        {
            this->forward_integrated_ephemeris_central_body_SPICE_ID = std::stoi(linecell[1]);
            
            //bounds check
            if (this->forward_integrated_ephemeris_central_body_SPICE_ID < this->forward_integrated_ephemeris_central_body_SPICE_ID_lowerBound || this->forward_integrated_ephemeris_central_body_SPICE_ID > this->forward_integrated_ephemeris_central_body_SPICE_ID_upperBound)
            {
                throw std::out_of_range("Input option forward_integrated_ephemeris_central_body_SPICE_ID is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->forward_integrated_ephemeris_central_body_SPICE_ID) + ", bounds are [" + std::to_string(this->forward_integrated_ephemeris_central_body_SPICE_ID_lowerBound) + ", " + std::to_string(this->forward_integrated_ephemeris_central_body_SPICE_ID_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "add_control_switch_line_to_ephemeris")
        {
            this->add_control_switch_line_to_ephemeris = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_mass_to_ephemeris_output")
        {
            this->append_mass_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_control_to_ephemeris_output")
        {
            this->append_control_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_thrust_to_ephemeris_output")
        {
            this->append_thrust_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_mdot_to_ephemeris_output")
        {
            this->append_mdot_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_Isp_to_ephemeris_output")
        {
            this->append_Isp_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_active_power_to_ephemeris_output")
        {
            this->append_active_power_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_number_of_active_engines_to_ephemeris_output")
        {
            this->append_number_of_active_engines_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "append_throttle_level_to_ephemeris_output")
        {
            this->append_throttle_level_to_ephemeris_output = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "call_system_to_generate_bsp")
        {
            this->call_system_to_generate_bsp = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "spice_utilities_path")
        {
            this->spice_utilities_path = linecell[1];
            return;
        }
        if (linecell[0] == "spice_utility_extension")
        {
            this->spice_utility_extension = linecell[1];
            return;
        }
        if (linecell[0] == "pyemtg_path")
        {
            this->pyemtg_path = linecell[1];
            return;
        }
        if (linecell[0] == "spacecraft_SPICE_ID")
        {
            this->spacecraft_SPICE_ID = std::stoi(linecell[1]);
            
            //bounds check
            if (this->spacecraft_SPICE_ID < this->spacecraft_SPICE_ID_lowerBound || this->spacecraft_SPICE_ID > this->spacecraft_SPICE_ID_upperBound)
            {
                throw std::out_of_range("Input option spacecraft_SPICE_ID is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->spacecraft_SPICE_ID) + ", bounds are [" + std::to_string(this->spacecraft_SPICE_ID_lowerBound) + ", " + std::to_string(this->spacecraft_SPICE_ID_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "background_mode")
        {
            this->background_mode = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "output_STMs")
        {
            this->output_STMs = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "output_maneuver_and_target_spec_files")
        {
            this->output_maneuver_and_target_spec_files = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "generate_acceleration_model_instrumentation_file")
        {
            this->generate_acceleration_model_instrumentation_file = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "stop_after_journey")
        {
            this->stop_after_journey = std::stoi(linecell[1]);
            
            //bounds check
            if (this->stop_after_journey < this->stop_after_journey_lowerBound || this->stop_after_journey > this->stop_after_journey_upperBound)
            {
                throw std::out_of_range("Input option stop_after_journey is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->stop_after_journey) + ", bounds are [" + std::to_string(this->stop_after_journey_lowerBound) + ", " + std::to_string(this->stop_after_journey_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "run_inner_loop")
        {
            this->run_inner_loop = (InnerLoopSolverType) std::stoi(linecell[1]);
            
            //bounds check
            if (this->run_inner_loop < this->run_inner_loop_lowerBound || this->run_inner_loop > this->run_inner_loop_upperBound)
            {
                throw std::out_of_range("Input option run_inner_loop is out of bounds on line " + std::to_string(lineNumber) + ". Value is " + std::to_string(this->run_inner_loop) + ", bounds are [" + std::to_string(this->run_inner_loop_lowerBound) + ", " + std::to_string(this->run_inner_loop_upperBound) + "].");
            }
            return;
        }
        if (linecell[0] == "check_derivatives")
        {
            this->check_derivatives = (bool) std::stoi(linecell[1]);
            return;
        }
        if (linecell[0] == "user_data")
        {
            if (line != "user_data")
            {
                this->user_data = line;
                this->user_data.erase(this->user_data.begin(), this->user_data.begin() + 10);
            }
            return;
        }
        
        //If we got this far, then the option was not recognized
        std::cout << "Option " << linecell[0] << " on line " << lineNumber << " is not recognized. Moving on with life..." << std::endl;
    }//end parse_line()
    
    void missionoptions::write(std::string optionsFileName, const bool& writeAll)
    {
        std::ofstream optionsFileStream(optionsFileName, std::ios::trunc);
        optionsFileStream.precision(20);
        
        optionsFileStream << "#EMTGv9 .emtgopt file version 2" << std::endl;
        optionsFileStream << std::endl;
        
        if (this->mission_name != "default" || writeAll)
        {
            optionsFileStream << "#mission name" << std::endl;
            optionsFileStream << "mission_name " << this->mission_name << std::endl;
        }
    
        if (this->objective_type != 2 || writeAll)
        {
            optionsFileStream << "#objective function type\n#0: minimum deltaV\n#1: minimum time\n#2: maximum final mass\n#3: maximize initial mass\n#4: depart as late as possible in the window\n#5: depart as early as possible in the window\n#6: maximize orbit energy\n#7: minimize launch mass\n#8: arrive as early as possible\n#9: arrive as late as possible\n#10: <PLACEHOLDER FOR FUTURE OBJECTIVE FUNCTIONS>\n#11: maximum dry/wet ratio\n#12: maximum arrival kinetic energy\n#13: minimum BOL power\n#14: maximize log_10(final mass)\n#15: maximum log_e(final mass)\n#16: maximum dry mass margin\n#17: maximum dry mass\n#18: maximum log_10(dry mass)\n#19: maximum log_e(dry mass)\n#20: minimize chemical fuel\n#21: minimize chemical oxidizer\n#22: minimize electric propellant\n#23: minimize total propellant\n#24: minimize waypoint tracking error\n#25: minimize initial impulse magnitude\n#26: maximize distance from central body" << std::endl;
            optionsFileStream << "objective_type " << this->objective_type << std::endl;
        }
    
        if (this->objective_journey != 0 || writeAll)
        {
            optionsFileStream << "#Journey associated with objective function (if applicable)" << std::endl;
            optionsFileStream << "objective_journey " << this->objective_journey << std::endl;
        }
    
        if (this->include_initial_impulse_in_cost != 0 || writeAll)
        {
            optionsFileStream << "#Include the initial impulse in calculating the delta-v objective function?" << std::endl;
            optionsFileStream << "include_initial_impulse_in_cost " << this->include_initial_impulse_in_cost << std::endl;
        }
    
        if (this->global_timebounded != 1 || writeAll)
        {
            optionsFileStream << "#0: unbounded, 1: bounded total time (note that the global arrival date bound is by definition the same as the last journey's arrival date bound and is not duplicated" << std::endl;
            optionsFileStream << "global_timebounded " << this->global_timebounded << std::endl;
        }
    
        if (this->launch_window_open_date != 53782 * 86400.0 || writeAll)
        {
            optionsFileStream << "#launch window open date (MJD)" << std::endl;
            optionsFileStream << "launch_window_open_date " << this->launch_window_open_date / 86400.0 << std::endl;
        }
    
        if (this->total_flight_time_bounds != std::vector<double>({ 0.0 * 86400.0, 302 * 86400.0}) || writeAll)
        {
            optionsFileStream << "#flight time bounds (days)" << std::endl;
            optionsFileStream << "total_flight_time_bounds";
            for (double entry : this->total_flight_time_bounds)
                optionsFileStream << " " << entry / 86400.0;
            optionsFileStream << std::endl;
        }
        
        if (this->DLA_bounds != std::vector<double>({ -90.0, 90.0}) || writeAll)
        {
            optionsFileStream << "#DLA in degrees" << std::endl;
            optionsFileStream << "DLA_bounds";
            for (double entry : this->DLA_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->RLA_bounds != std::vector<double>({ -2880.0, 2880.0}) || writeAll)
        {
            optionsFileStream << "#RLA in degrees" << std::endl;
            optionsFileStream << "RLA_bounds";
            for (double entry : this->RLA_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->mission_type != 2 || writeAll)
        {
            optionsFileStream << "#phase type\n#0: MGALTS\n#1: FBLTS\n#2: MGALT\n#3: FBLT\n#4: PSBI\n#5: PSFB\n#6: MGAnDSMs\n#7: CoastPhase\n#8: SundmanCoastPhase\n#9: variable phase type\n#10: ProbeEntryPhase\n#11 ControlLawThrustPhase" << std::endl;
            optionsFileStream << "mission_type " << this->mission_type << std::endl;
        }
    
        if (this->NLP_solver_type != 0 || writeAll)
        {
            optionsFileStream << "#NLP solver type\n#0: SNOPT\n#1: WORHP\n#2: IPOPT-MA27\n#3: IPOPT-MUMPS" << std::endl;
            optionsFileStream << "NLP_solver_type " << this->NLP_solver_type << std::endl;
        }
    
        if (this->NLP_solver_mode != 1 || writeAll)
        {
            optionsFileStream << "#NLP solver mode\n#0: find feasible point only\n#1: find optimal solution\n#2: satisfy equality constraints" << std::endl;
            optionsFileStream << "NLP_solver_mode " << this->NLP_solver_mode << std::endl;
        }
    
        if (this->quiet_NLP != 1 || writeAll)
        {
            optionsFileStream << "#Quiet NLP solver?" << std::endl;
            optionsFileStream << "quiet_NLP " << this->quiet_NLP << std::endl;
        }
    
        if (this->ACE_feasible_point_finder != 0 || writeAll)
        {
            optionsFileStream << "#Enable ACE feasible point finder?" << std::endl;
            optionsFileStream << "ACE_feasible_point_finder " << this->ACE_feasible_point_finder << std::endl;
        }
    
        if (this->MBH_always_write_archive != 0 || writeAll)
        {
            optionsFileStream << "#Write every hop to the MBH archive, even if it is not an improvement?" << std::endl;
            optionsFileStream << "MBH_always_write_archive " << this->MBH_always_write_archive << std::endl;
        }
    
        if (this->MBH_archive_state_vector != 0 || writeAll)
        {
            optionsFileStream << "#include state vector in MBH archive file?" << std::endl;
            optionsFileStream << "MBH_archive_state_vector " << this->MBH_archive_state_vector << std::endl;
        }
    
        if (this->MBH_max_not_improve != 10000 || writeAll)
        {
            optionsFileStream << "#quantity Max_not_improve for MBH" << std::endl;
            optionsFileStream << "MBH_max_not_improve " << this->MBH_max_not_improve << std::endl;
        }
    
        if (this->MBH_max_trials != 1000000 || writeAll)
        {
            optionsFileStream << "#maximum number of trials for MBH" << std::endl;
            optionsFileStream << "MBH_max_trials " << this->MBH_max_trials << std::endl;
        }
    
        if (this->MBH_max_run_time != 60 || writeAll)
        {
            optionsFileStream << "#maximum run time for MBH, in seconds" << std::endl;
            optionsFileStream << "MBH_max_run_time " << this->MBH_max_run_time << std::endl;
        }
    
        if (this->MBH_max_step_size != 1 || writeAll)
        {
            optionsFileStream << "#Maximum step size (uniform) or scale factor (other distributions)" << std::endl;
            optionsFileStream << "MBH_max_step_size " << this->MBH_max_step_size << std::endl;
        }
    
        if (this->MBH_hop_distribution != 2 || writeAll)
        {
            optionsFileStream << "#MBH hop probabilty distribution\n#0: uniform\n#1: Cauchy\n#2: Pareto\n#3: Gaussian" << std::endl;
            optionsFileStream << "MBH_hop_distribution " << this->MBH_hop_distribution << std::endl;
        }
    
        if (this->MBH_Pareto_alpha != 1.4 || writeAll)
        {
            optionsFileStream << "#Pareto distribution alpha" << std::endl;
            optionsFileStream << "MBH_Pareto_alpha " << this->MBH_Pareto_alpha << std::endl;
        }
    
        if (this->MBH_write_every_improvement != 0 || writeAll)
        {
            optionsFileStream << "#Write every MBH improvement for later animation?" << std::endl;
            optionsFileStream << "MBH_write_every_improvement " << this->MBH_write_every_improvement << std::endl;
        }
    
        if (this->MBH_time_hop_probability != 0.05 || writeAll)
        {
            optionsFileStream << "#probability of MBH time hop operation" << std::endl;
            optionsFileStream << "MBH_time_hop_probability " << this->MBH_time_hop_probability << std::endl;
        }
    
        if (this->snopt_feasibility_tolerance != 1.00E-05 || writeAll)
        {
            optionsFileStream << "#feasibility tolerance" << std::endl;
            optionsFileStream << "snopt_feasibility_tolerance " << this->snopt_feasibility_tolerance << std::endl;
        }
    
        if (this->snopt_optimality_tolerance != 1.00E-05 || writeAll)
        {
            optionsFileStream << "#optimality tolerance" << std::endl;
            optionsFileStream << "snopt_optimality_tolerance " << this->snopt_optimality_tolerance << std::endl;
        }
    
        if (this->NLP_max_step != 1 || writeAll)
        {
            optionsFileStream << "#NLP max step" << std::endl;
            optionsFileStream << "NLP_max_step " << this->NLP_max_step << std::endl;
        }
    
        if (this->snopt_major_iterations != 8000 || writeAll)
        {
            optionsFileStream << "#NLP major iterations" << std::endl;
            optionsFileStream << "snopt_major_iterations " << this->snopt_major_iterations << std::endl;
        }
    
        if (this->snopt_minor_iterations != 500 || writeAll)
        {
            optionsFileStream << "#NLP minor iterations" << std::endl;
            optionsFileStream << "snopt_minor_iterations " << this->snopt_minor_iterations << std::endl;
        }
    
        if (this->snopt_max_run_time != 15 || writeAll)
        {
            optionsFileStream << "#NLP max run time (seconds)" << std::endl;
            optionsFileStream << "snopt_max_run_time " << this->snopt_max_run_time << std::endl;
        }
    
        if (this->enable_Scalatron != 1 || writeAll)
        {
            optionsFileStream << "#Enable Scalatron?" << std::endl;
            optionsFileStream << "enable_Scalatron " << this->enable_Scalatron << std::endl;
        }
    
        if (this->enable_NLP_chaperone != 1 || writeAll)
        {
            optionsFileStream << "#Enable NLP chaperone?" << std::endl;
            optionsFileStream << "enable_NLP_chaperone " << this->enable_NLP_chaperone << std::endl;
        }
    
        if (this->seed_MBH != 0 || writeAll)
        {
            optionsFileStream << "#Seed MBH?" << std::endl;
            optionsFileStream << "seed_MBH " << this->seed_MBH << std::endl;
        }
    
        if (this->skip_first_nlp_run != 0 || writeAll)
        {
            optionsFileStream << "#Skip first NLP run in an MBH process?" << std::endl;
            optionsFileStream << "skip_first_nlp_run " << this->skip_first_nlp_run << std::endl;
        }
    
        if (this->NLP_stop_on_goal_attain != 0 || writeAll)
        {
            optionsFileStream << "#Stop NLP on goal attain?" << std::endl;
            optionsFileStream << "NLP_stop_on_goal_attain " << this->NLP_stop_on_goal_attain << std::endl;
        }
    
        if (this->NLP_objective_goal != 0 || writeAll)
        {
            optionsFileStream << "#Objective value at which NLP stops" << std::endl;
            optionsFileStream << "NLP_objective_goal " << this->NLP_objective_goal << std::endl;
        }
    
        if (this->MBH_RNG_seed != -1 || writeAll)
        {
            optionsFileStream << "#MBH RNG seed (negative number means system clock)" << std::endl;
            optionsFileStream << "MBH_RNG_seed " << this->MBH_RNG_seed << std::endl;
        }
    
        if (this->print_NLP_movie_frames != 0 || writeAll)
        {
            optionsFileStream << "#Print NLP movie frames?" << std::endl;
            optionsFileStream << "print_NLP_movie_frames " << this->print_NLP_movie_frames << std::endl;
        }
    
        if (this->quiet_basinhopping != 0 || writeAll)
        {
            optionsFileStream << "#Quiet MBH?" << std::endl;
            optionsFileStream << "quiet_basinhopping " << this->quiet_basinhopping << std::endl;
        }
    
        if (this->SPICE_leap_seconds_kernel != "naif0012.tls" || writeAll)
        {
            optionsFileStream << "#SPICE leap seconds kernel - required for SPICE to work" << std::endl;
            optionsFileStream << "SPICE_leap_seconds_kernel " << this->SPICE_leap_seconds_kernel << std::endl;
        }
    
        if (this->SPICE_reference_frame_kernel != "pck00010.tpc" || writeAll)
        {
            optionsFileStream << "#SPICE_reference_frame_kernel" << std::endl;
            optionsFileStream << "SPICE_reference_frame_kernel " << this->SPICE_reference_frame_kernel << std::endl;
        }
    
        if (this->universe_folder != "C:/Utilities/Universe" || writeAll)
        {
            optionsFileStream << "#Universe folder" << std::endl;
            optionsFileStream << "universe_folder " << this->universe_folder << std::endl;
        }
    
        if (this->ephemeris_source != 2 || writeAll)
        {
            optionsFileStream << "#0: static, 1: SPICE (default to static if no SPICE file supplied for a body), 2: SplineEphem" << std::endl;
            optionsFileStream << "ephemeris_source " << this->ephemeris_source << std::endl;
        }
    
        if (this->SplineEphem_points_per_period != 360 || writeAll)
        {
            optionsFileStream << "#How many sample points should SplineEphem use per orbital period of each body?" << std::endl;
            optionsFileStream << "SplineEphem_points_per_period " << this->SplineEphem_points_per_period << std::endl;
        }
    
        if (this->SplineEphem_non_central_body_sun_points_per_period != 10000 || writeAll)
        {
            optionsFileStream << "#How many sample points should SplineEphem use per orbital period of the sun with respect to the central body?" << std::endl;
            optionsFileStream << "SplineEphem_non_central_body_sun_points_per_period " << this->SplineEphem_non_central_body_sun_points_per_period << std::endl;
        }
    
        if (this->SplineEphem_truncate_ephemeris_at_maximum_mission_epoch != 0 || writeAll)
        {
            optionsFileStream << "#Truncate SplineEphem at maximum mission epoch?\n#If you enable this option, global search will be impeded but you will save a lot of memory\n#Useful for monte-carlo, launch period analysis, etc." << std::endl;
            optionsFileStream << "SplineEphem_truncate_ephemeris_at_maximum_mission_epoch " << this->SplineEphem_truncate_ephemeris_at_maximum_mission_epoch << std::endl;
        }
    
        if (this->earliestPossibleEpoch != 51554.5 || writeAll)
        {
            optionsFileStream << "#Beginning of the SplineEphem data set" << std::endl;
            optionsFileStream << "earliestPossibleEpoch " << this->earliestPossibleEpoch << std::endl;
        }
    
        if (this->latestPossibleEpoch != 88058 || writeAll)
        {
            optionsFileStream << "#End of the SplineEphem data set" << std::endl;
            optionsFileStream << "latestPossibleEpoch " << this->latestPossibleEpoch << std::endl;
        }
    
        if (this->propagatorType != 0 || writeAll)
        {
            optionsFileStream << "#Propagator type\n#0: Keplerian propagator\n#1: Integrated propagator" << std::endl;
            optionsFileStream << "propagatorType " << this->propagatorType << std::endl;
        }
    
        if (this->integratorType != 1 || writeAll)
        {
            optionsFileStream << "#Integrator type\n#0: rk7813M adaptive step\n#1: rk8 fixed step" << std::endl;
            optionsFileStream << "integratorType " << this->integratorType << std::endl;
        }
    
        if (this->integrator_tolerance != 1.00E-08 || writeAll)
        {
            optionsFileStream << "#adaptive step integrator tolerance" << std::endl;
            optionsFileStream << "integrator_tolerance " << this->integrator_tolerance << std::endl;
        }
    
        if (this->integration_time_step_size != 86400 || writeAll)
        {
            optionsFileStream << "#integration step size (maximum for adaptive, fixed for fixed)" << std::endl;
            optionsFileStream << "integration_time_step_size " << this->integration_time_step_size << std::endl;
        }
    
        if (this->num_timesteps != 20 || writeAll)
        {
            optionsFileStream << "#number of timesteps per phase" << std::endl;
            optionsFileStream << "num_timesteps " << this->num_timesteps << std::endl;
        }
    
        if (this->spiral_segments != 1 || writeAll)
        {
            optionsFileStream << "#number of spiral segments" << std::endl;
            optionsFileStream << "spiral_segments " << this->spiral_segments << std::endl;
        }
    
        if (this->allow_initial_mass_to_vary != 0 || writeAll)
        {
            optionsFileStream << "#Allow the mass at the beginning of the first journey to vary up to the allowed maximum?" << std::endl;
            optionsFileStream << "allow_initial_mass_to_vary " << this->allow_initial_mass_to_vary << std::endl;
        }
    
        if (this->maximum_mass != 525.2 || writeAll)
        {
            optionsFileStream << "#maximum possible mass of the spacecraft (kg)" << std::endl;
            optionsFileStream << "maximum_mass " << this->maximum_mass << std::endl;
        }
    
        if (this->IspLT != 3000 || writeAll)
        {
            optionsFileStream << "#specific impulse of the engine used for low-thrust maneuvers" << std::endl;
            optionsFileStream << "IspLT " << this->IspLT << std::endl;
        }
    
        if (this->IspLT_minimum != 1 || writeAll)
        {
            optionsFileStream << "#minimum specific impulse for variable specific impulse problems" << std::endl;
            optionsFileStream << "IspLT_minimum " << this->IspLT_minimum << std::endl;
        }
    
        if (this->IspChem != 320 || writeAll)
        {
            optionsFileStream << "#specific impulse of the engine used for impulsive maneuvers" << std::endl;
            optionsFileStream << "IspChem " << this->IspChem << std::endl;
        }
    
        if (this->Thrust != 0.1 || writeAll)
        {
            optionsFileStream << "#thrust of the spacecraft, in Newtons" << std::endl;
            optionsFileStream << "Thrust " << this->Thrust << std::endl;
        }
    
        if (this->LV_margin != 0 || writeAll)
        {
            optionsFileStream << "#LV margin (as a fraction)" << std::endl;
            optionsFileStream << "LV_margin " << this->LV_margin << std::endl;
        }
    
        if (this->LV_adapter_mass != 0 || writeAll)
        {
            optionsFileStream << "#LV adapter mass (kg)" << std::endl;
            optionsFileStream << "LV_adapter_mass " << this->LV_adapter_mass << std::endl;
        }
    
        if (this->engine_type != 5 || writeAll)
        {
            optionsFileStream << "#low-thrust engine type\n#0: fixed thrust/Isp\n#1: constant Isp, efficiency, EMTG computes input power\n#2: choice of power model, constant efficiency, EMTG chooses Isp\n#3: choice of power model, constant efficiency and Isp\n#4: continuously-varying specific impulse\n#5: custom thrust and mass flow rate polynomial\n#6: NSTAR\n#7: XIPS-25\n#8: BPT-4000 High-Isp\n#9: BPT-4000 High-Thrust\n#10: BPT-4000 Ex-High-Isp\n#11: NEXT high-Isp v9\n#12: VASIMR (argon, using analytical model)\n#13: Hall Thruster (Xenon, using analytical model)\n#14: NEXT high-ISP v10\n#15: NEXT high-thrust v10\n#16: BPT-4000 MALTO\n#17: NEXIS Cardiff 8-15-201\n#18: H6MS Cardiff 8-15-2013\n#19: BHT20K Cardiff 8-16-2013\n#20: Aerojet HiVHAC EM\n#21: 13 kW STMD Hall high-Isp (not available in open-source)\n#22: 13 kW STMD Hall high-thrust (not available in open-source)\n#23: NEXT TT11 High-Thrust\n#24: NEXT TT11 High-Isp\n#25: NEXT TT11 Expanded Throttle Table\n#26: 13 kW STMD Hall high-Isp 10-1-2014 (not available in open-source)\n#27: 13 kW STMD Hall medium-thrust 10-1-2014 (not available in open-source)\n#28: 13 kW STMD Hall high-thrust 10-1-2014 (not available in open-source)\n#29: 2D Throttle table\n#30: 1D Throttle table high-thrust\n#31: 1D Throttle table high-Isp\n#32: 2D polynomial fit" << std::endl;
            optionsFileStream << "engine_type " << this->engine_type << std::endl;
        }
    
        if (this->number_of_electric_propulsion_systems != 1 || writeAll)
        {
            optionsFileStream << "#number of thruster systems (used to be called number of engines)" << std::endl;
            optionsFileStream << "number_of_electric_propulsion_systems " << this->number_of_electric_propulsion_systems << std::endl;
        }
    
        if (this->engine_duty_cycle != 1 || writeAll)
        {
            optionsFileStream << "#percentage of time that engine can operate" << std::endl;
            optionsFileStream << "engine_duty_cycle " << this->engine_duty_cycle << std::endl;
        }
    
        if (this->duty_cycle_type != 0 || writeAll)
        {
            optionsFileStream << "#duty cycle type\n#0: averaged\n#1: realistic" << std::endl;
            optionsFileStream << "duty_cycle_type " << this->duty_cycle_type << std::endl;
        }
    
        if (this->thrust_scale_factor != 1 || writeAll)
        {
            optionsFileStream << "#scale factor to apply to thrust ONLY, not mass flow rate, can use to approximate cosine loss" << std::endl;
            optionsFileStream << "thrust_scale_factor " << this->thrust_scale_factor << std::endl;
        }
    
        if (this->power_at_1_AU != 5 || writeAll)
        {
            optionsFileStream << "#Power at 1 AU (kW)" << std::endl;
            optionsFileStream << "power_at_1_AU " << this->power_at_1_AU << std::endl;
        }
    
        if (this->power_source_type != 1 || writeAll)
        {
            optionsFileStream << "#power source type, 0: fixed, 1: solar" << std::endl;
            optionsFileStream << "power_source_type " << this->power_source_type << std::endl;
        }
    
        if (this->solar_power_model_type != 0 || writeAll)
        {
            optionsFileStream << "#Solar power model type\n#0: classic Sauer model\n#1: polynomial (0th order on the left)" << std::endl;
            optionsFileStream << "solar_power_model_type " << this->solar_power_model_type << std::endl;
        }
    
        if (this->solar_power_gamma != std::vector<double>({ 1.32077, -0.10848, -0.11665, 0.10843, -0.01279, 0.0, 0.0}) || writeAll)
        {
            optionsFileStream << "#solar power coefficients gamma_1 through gamma_5, if all gamma = [1 0 0 0 0], then solar power is a simple 1/r^2" << std::endl;
            optionsFileStream << "solar_power_gamma";
            for (double entry : this->solar_power_gamma)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->power_margin != 0 || writeAll)
        {
            optionsFileStream << "#power margin (fraction)" << std::endl;
            optionsFileStream << "power_margin " << this->power_margin << std::endl;
        }
    
        if (this->power_decay_rate != 0 || writeAll)
        {
            optionsFileStream << "#power system decay rate (fraction per year)" << std::endl;
            optionsFileStream << "power_decay_rate " << this->power_decay_rate << std::endl;
        }
    
        if (this->power_decay_type != 0 || writeAll)
        {
            optionsFileStream << "#How to model power decay.\n#0: e^(-t * power_decay_rate) \n#2: decay_coeff[0] + decay_coeff[1] * e^(decay_coeff[2] * t) + decay_coeff[3] * t" << std::endl;
            optionsFileStream << "power_decay_type " << this->power_decay_type << std::endl;
        }
    
        if (this->decay_coefficients != std::vector<double>({ 1, 0, 0, 0}) || writeAll)
        {
            optionsFileStream << "#Decay coefficients if power_decay_type = 1" << std::endl;
            optionsFileStream << "decay_coefficients";
            for (double entry : this->decay_coefficients)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->power_system_decay_reference_epoch != 51544.5 * 86400.0 || writeAll)
        {
            optionsFileStream << "#reference date when the power system begins to decay" << std::endl;
            optionsFileStream << "power_system_decay_reference_epoch " << this->power_system_decay_reference_epoch / 86400.0 << std::endl;
        }
    
        if (this->throttle_sharpness != 100 || writeAll)
        {
            optionsFileStream << "#Throttle sharpness (higher means more precise, lower means smoother)" << std::endl;
            optionsFileStream << "throttle_sharpness " << this->throttle_sharpness << std::endl;
        }
    
        if (this->throttle_logic_mode != 1 || writeAll)
        {
            optionsFileStream << "#Throttle logic mode\n#0: maximum number of thrusters\n#1: minimum number of thrusters" << std::endl;
            optionsFileStream << "throttle_logic_mode " << this->throttle_logic_mode << std::endl;
        }
    
        if (this->spacecraft_power_coefficients != std::vector<double>({ 0, 0, 0}) || writeAll)
        {
            optionsFileStream << "#spacecraft power coefficients A, B, and C\n#represent the power requirements of the spacecraft at a distance r from the sun\n#i.e. heaters, communications, etc" << std::endl;
            optionsFileStream << "spacecraft_power_coefficients";
            for (double entry : this->spacecraft_power_coefficients)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->engine_input_thrust_coefficients != std::vector<double>({ 26.337459, -51.694393, 90.486509, -36.720293, 5.145602, 0.0, 0.0}) || writeAll)
        {
            optionsFileStream << "#thrust polynomial coefficients" << std::endl;
            optionsFileStream << "engine_input_thrust_coefficients";
            for (double entry : this->engine_input_thrust_coefficients)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->engine_input_mass_flow_rate_coefficients != std::vector<double>({ 2.506, -5.3568, 6.2539, -2.5372, 0.36985, 0.0, 0.0}) || writeAll)
        {
            optionsFileStream << "#mass flow rate polynomial coefficients" << std::endl;
            optionsFileStream << "engine_input_mass_flow_rate_coefficients";
            for (double entry : this->engine_input_mass_flow_rate_coefficients)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->engine_input_power_bounds != std::vector<double>({ 0.525, 2.6}) || writeAll)
        {
            optionsFileStream << "#thruster input power bounds (kW)" << std::endl;
            optionsFileStream << "engine_input_power_bounds";
            for (double entry : this->engine_input_power_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->user_defined_engine_efficiency != 0.7 || writeAll)
        {
            optionsFileStream << "#Propulsion system efficiency (fraction)" << std::endl;
            optionsFileStream << "user_defined_engine_efficiency " << this->user_defined_engine_efficiency << std::endl;
        }
    
        if (this->spacecraft_power_model_type != 0 || writeAll)
        {
            optionsFileStream << "#spacecraft power model type\n#0: P_sc = A + B/r + C/r^2\n#1: P_sc = A if P > A, A + B(C - P) otherwise" << std::endl;
            optionsFileStream << "spacecraft_power_model_type " << this->spacecraft_power_model_type << std::endl;
        }
    
        if (this->TCM_Isp != 200 || writeAll)
        {
            optionsFileStream << "#Isp for TCMs" << std::endl;
            optionsFileStream << "TCM_Isp " << this->TCM_Isp << std::endl;
        }
    
        if (this->TCM_post_launch != 0 || writeAll)
        {
            optionsFileStream << "#TCM magnitude post-launch (km/s)" << std::endl;
            optionsFileStream << "TCM_post_launch " << this->TCM_post_launch << std::endl;
        }
    
        if (this->TCM_pre_flyby != 0 || writeAll)
        {
            optionsFileStream << "#TCM magnitude before flybys (km/s)" << std::endl;
            optionsFileStream << "TCM_pre_flyby " << this->TCM_pre_flyby << std::endl;
        }
    
        if (this->TCM_maneuver_fraction != 0 || writeAll)
        {
            optionsFileStream << "#Post-DSM TCM magnitude as a fraction of DSM magnitude" << std::endl;
            optionsFileStream << "TCM_maneuver_fraction " << this->TCM_maneuver_fraction << std::endl;
        }
    
        if (this->trackACS != 0 || writeAll)
        {
            optionsFileStream << "#Track ACS propellant consumption?" << std::endl;
            optionsFileStream << "trackACS " << this->trackACS << std::endl;
        }
    
        if (this->ACS_kg_per_day != 0 || writeAll)
        {
            optionsFileStream << "#ACS propellant consumption (kg/day)" << std::endl;
            optionsFileStream << "ACS_kg_per_day " << this->ACS_kg_per_day << std::endl;
        }
    
        if (this->final_mass_constraint_bounds != std::vector<double>({ 0.0, 0.0}) || writeAll)
        {
            optionsFileStream << "#Bounds on final mass constraints" << std::endl;
            optionsFileStream << "final_mass_constraint_bounds";
            for (double entry : this->final_mass_constraint_bounds)
                optionsFileStream << " " << entry;
            optionsFileStream << std::endl;
        }
        
        if (this->constrain_final_mass != 0 || writeAll)
        {
            optionsFileStream << "#Constrain final wet mass?" << std::endl;
            optionsFileStream << "constrain_final_mass " << this->constrain_final_mass << std::endl;
        }
    
        if (this->constrain_dry_mass != 0 || writeAll)
        {
            optionsFileStream << "#Constrain dry mass?" << std::endl;
            optionsFileStream << "constrain_dry_mass " << this->constrain_dry_mass << std::endl;
        }
    
        if (this->enable_electric_propellant_tank_constraint != 0 || writeAll)
        {
            optionsFileStream << "#Constrain electric propellant tank?" << std::endl;
            optionsFileStream << "enable_electric_propellant_tank_constraint " << this->enable_electric_propellant_tank_constraint << std::endl;
        }
    
        if (this->maximum_electric_propellant != 1000 || writeAll)
        {
            optionsFileStream << "#Electric propellant tank capacity (kg)" << std::endl;
            optionsFileStream << "maximum_electric_propellant " << this->maximum_electric_propellant << std::endl;
        }
    
        if (this->electric_propellant_margin != 0 || writeAll)
        {
            optionsFileStream << "#Electric propellant margin (fraction)" << std::endl;
            optionsFileStream << "electric_propellant_margin " << this->electric_propellant_margin << std::endl;
        }
    
        if (this->enable_chemical_propellant_tank_constraint != 0 || writeAll)
        {
            optionsFileStream << "#Constrain chemical propellant?" << std::endl;
            optionsFileStream << "enable_chemical_propellant_tank_constraint " << this->enable_chemical_propellant_tank_constraint << std::endl;
        }
    
        if (this->maximum_chemical_fuel != 1000 || writeAll)
        {
            optionsFileStream << "#Chemical fuel tank capacity (kg)" << std::endl;
            optionsFileStream << "maximum_chemical_fuel " << this->maximum_chemical_fuel << std::endl;
        }
    
        if (this->maximum_chemical_oxidizer != 1000 || writeAll)
        {
            optionsFileStream << "#Chemical oxidizer tank capacity (kg)" << std::endl;
            optionsFileStream << "maximum_chemical_oxidizer " << this->maximum_chemical_oxidizer << std::endl;
        }
    
        if (this->bipropellant_mixture_ratio != 0.925 || writeAll)
        {
            optionsFileStream << "#Bipropellant mixture ratio" << std::endl;
            optionsFileStream << "bipropellant_mixture_ratio " << this->bipropellant_mixture_ratio << std::endl;
        }
    
        if (this->chemical_propellant_margin != 0 || writeAll)
        {
            optionsFileStream << "#Chemical propellant margin (fraction)" << std::endl;
            optionsFileStream << "chemical_propellant_margin " << this->chemical_propellant_margin << std::endl;
        }
    
        if (this->SpacecraftModelInput != 2 || writeAll)
        {
            optionsFileStream << "#Spacecraft object input type\n#0: Assemble from libraries\n#1: Read .emtg_spacecraftoptions file\n#2: Assemble from missionoptions object" << std::endl;
            optionsFileStream << "SpacecraftModelInput " << this->SpacecraftModelInput << std::endl;
        }
    
        if (this->HardwarePath != "c:/Utilities/HardwareModels/" || writeAll)
        {
            optionsFileStream << "#HardwarePath" << std::endl;
            optionsFileStream << "HardwarePath " << this->HardwarePath << std::endl;
        }
    
        if (this->ThrottleTableFile != "empty.ThrottleTable" || writeAll)
        {
            optionsFileStream << "#ThrottleTableFile" << std::endl;
            optionsFileStream << "ThrottleTableFile " << this->ThrottleTableFile << std::endl;
        }
    
        if (this->LaunchVehicleLibraryFile != "default.emtg_launchvehicleopt" || writeAll)
        {
            optionsFileStream << "#LaunchVehicleLibraryFile" << std::endl;
            optionsFileStream << "LaunchVehicleLibraryFile " << this->LaunchVehicleLibraryFile << std::endl;
        }
    
        if (this->PowerSystemsLibraryFile != "default.emtg_powersystemsopt" || writeAll)
        {
            optionsFileStream << "#PowerSystemsLibraryFile" << std::endl;
            optionsFileStream << "PowerSystemsLibraryFile " << this->PowerSystemsLibraryFile << std::endl;
        }
    
        if (this->PropulsionSystemsLibraryFile != "default.emtg_propulsionsystemopt" || writeAll)
        {
            optionsFileStream << "#PropulsionSystemsLibraryFile" << std::endl;
            optionsFileStream << "PropulsionSystemsLibraryFile " << this->PropulsionSystemsLibraryFile << std::endl;
        }
    
        if (this->SpacecraftOptionsFile != "default.emtg_spacecraftopt" || writeAll)
        {
            optionsFileStream << "#SpacecraftOptionsFile" << std::endl;
            optionsFileStream << "SpacecraftOptionsFile " << this->SpacecraftOptionsFile << std::endl;
        }
    
        if (this->LaunchVehicleKey != "ExampleRocket" || writeAll)
        {
            optionsFileStream << "#LaunchVehicleKey" << std::endl;
            optionsFileStream << "LaunchVehicleKey " << this->LaunchVehicleKey << std::endl;
        }
    
        if (this->PowerSystemKey != "5kW_basic" || writeAll)
        {
            optionsFileStream << "#PowerSystemKey" << std::endl;
            optionsFileStream << "PowerSystemKey " << this->PowerSystemKey << std::endl;
        }
    
        if (this->ElectricPropulsionSystemKey != "defaultThruster" || writeAll)
        {
            optionsFileStream << "#ElectricPropulsionSystemKey" << std::endl;
            optionsFileStream << "ElectricPropulsionSystemKey " << this->ElectricPropulsionSystemKey << std::endl;
        }
    
        if (this->ChemicalPropulsionSystemKey != "DefaultChemicalPropulsionSystem" || writeAll)
        {
            optionsFileStream << "#ChemicalPropulsionSystemKey" << std::endl;
            optionsFileStream << "ChemicalPropulsionSystemKey " << this->ChemicalPropulsionSystemKey << std::endl;
        }
    
        if (this->perturb_SRP != 0 || writeAll)
        {
            optionsFileStream << "#solar radiation pressure?" << std::endl;
            optionsFileStream << "perturb_SRP " << this->perturb_SRP << std::endl;
        }
    
        if (this->perturb_thirdbody != 0 || writeAll)
        {
            optionsFileStream << "#third body perturbations?" << std::endl;
            optionsFileStream << "perturb_thirdbody " << this->perturb_thirdbody << std::endl;
        }
    
        if (this->perturb_J2 != 0 || writeAll)
        {
            optionsFileStream << "#J2?" << std::endl;
            optionsFileStream << "perturb_J2 " << this->perturb_J2 << std::endl;
        }
    
        if (this->spacecraft_area != 70 || writeAll)
        {
            optionsFileStream << "#spacecraft area (for SRP, in m^2)" << std::endl;
            optionsFileStream << "spacecraft_area " << this->spacecraft_area << std::endl;
        }
    
        if (this->coefficient_of_reflectivity != 1 || writeAll)
        {
            optionsFileStream << "#Coefficient of reflectivity" << std::endl;
            optionsFileStream << "coefficient_of_reflectivity " << this->coefficient_of_reflectivity << std::endl;
        }
    
        if (this->solar_percentage != 1 || writeAll)
        {
            optionsFileStream << "#Percentage of the Sun seen by the spacecraft" << std::endl;
            optionsFileStream << "solar_percentage " << this->solar_percentage << std::endl;
        }
    
        if (this->solar_flux != 1359.39 || writeAll)
        {
            optionsFileStream << "#Solar constant (flux density at 1 AU) [W/m^2 = kg/s^3]" << std::endl;
            optionsFileStream << "solar_flux " << this->solar_flux << std::endl;
        }
    
        if (this->speed_of_light_vac != 299792458 || writeAll)
        {
            optionsFileStream << "#Speed of light in a vacuum [m/s]" << std::endl;
            optionsFileStream << "speed_of_light_vac " << this->speed_of_light_vac << std::endl;
        }
    
        if (this->forced_post_launch_coast != 0 * 86400.0 || writeAll)
        {
            optionsFileStream << "#Forced post-launch coast, in days" << std::endl;
            optionsFileStream << "forced_post_launch_coast " << this->forced_post_launch_coast / 86400.0 << std::endl;
        }
    
        if (this->forced_pre_flyby_coast != 0 * 86400.0 || writeAll)
        {
            optionsFileStream << "#Forced pre-flyby coast, in days" << std::endl;
            optionsFileStream << "forced_pre_flyby_coast " << this->forced_pre_flyby_coast / 86400.0 << std::endl;
        }
    
        if (this->forced_post_flyby_coast != 0 * 86400.0 || writeAll)
        {
            optionsFileStream << "#Forced post-flyby coast, in days" << std::endl;
            optionsFileStream << "forced_post_flyby_coast " << this->forced_post_flyby_coast / 86400.0 << std::endl;
        }
    
        if (this->waypoint_file_path != "./banana.ephemeris" || writeAll)
        {
            optionsFileStream << "#Path to waypoint file" << std::endl;
            optionsFileStream << "waypoint_file_path " << this->waypoint_file_path << std::endl;
        }
    
        if (this->covariance_file_path != "./shampoo_bottle.ephemeris" || writeAll)
        {
            optionsFileStream << "#Path to covariance file" << std::endl;
            optionsFileStream << "covariance_file_path " << this->covariance_file_path << std::endl;
        }
    
        if (this->ParallelShootingStateRepresentation != 1 || writeAll)
        {
            optionsFileStream << "#state representation for parallel shooting (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE)" << std::endl;
            optionsFileStream << "ParallelShootingStateRepresentation " << this->ParallelShootingStateRepresentation << std::endl;
        }
    
        if (this->PeriapseBoundaryStateRepresentation != 1 || writeAll)
        {
            optionsFileStream << "#state representation for periapse boundary conditions (Cartesian, SphericalRADEC, SphericalAZFPA, COE, MEE, IncomingBplane, OutgoingBplane)" << std::endl;
            optionsFileStream << "PeriapseBoundaryStateRepresentation " << this->PeriapseBoundaryStateRepresentation << std::endl;
        }
    
        if (this->ParallelShootingConstraintStateRepresentation != 0 || writeAll)
        {
            optionsFileStream << "#state representation for parallel shooting constraints (Cartesian or same as encoded states)" << std::endl;
            optionsFileStream << "ParallelShootingConstraintStateRepresentation " << this->ParallelShootingConstraintStateRepresentation << std::endl;
        }
    
        if (this->print_only_non_default_options != 1 || writeAll)
        {
            optionsFileStream << "#Write only options that are *not* default into the .emtgopt file?" << std::endl;
            optionsFileStream << "print_only_non_default_options " << this->print_only_non_default_options << std::endl;
        }
    
        if (this->output_file_frame != 1 || writeAll)
        {
            optionsFileStream << "#reference frame for output file (0: J2000_ICRF, 1: J2000_BCI, 2: J2000_BCF, 3: TrueOfDate_BCI, 4: TrueOfDate_BCF, 5: Principle Axes, 6: Topocentric, 7: Polar)" << std::endl;
            optionsFileStream << "output_file_frame " << this->output_file_frame << std::endl;
        }
    
        if (this->override_default_output_file_name != 0 || writeAll)
        {
            optionsFileStream << "#Override default output file name?" << std::endl;
            optionsFileStream << "override_default_output_file_name " << this->override_default_output_file_name << std::endl;
        }
    
        if (this->forced_output_file_name != "forced_output_file_name" || writeAll)
        {
            optionsFileStream << "#User-defined output file name" << std::endl;
            optionsFileStream << "forced_output_file_name " << this->forced_output_file_name << std::endl;
        }
    
        if (this->output_dormant_journeys != 0 || writeAll)
        {
            optionsFileStream << "#Output ephemeris for time spent waiting between journeys?" << std::endl;
            optionsFileStream << "output_dormant_journeys " << this->output_dormant_journeys << std::endl;
        }
    
        if (this->post_mission_wait_time != 0 || writeAll)
        {
            optionsFileStream << "#How long to output an ephemeris after the mission end (days)" << std::endl;
            optionsFileStream << "post_mission_wait_time " << this->post_mission_wait_time << std::endl;
        }
    
        if (this->override_working_directory != 0 || writeAll)
        {
            optionsFileStream << "#Override the working directory?" << std::endl;
            optionsFileStream << "override_working_directory " << this->override_working_directory << std::endl;
        }
    
        if (this->forced_working_directory != "..//EMTG_v9_Results" || writeAll)
        {
            optionsFileStream << "#User-defined working directory" << std::endl;
            optionsFileStream << "forced_working_directory " << this->forced_working_directory << std::endl;
        }
    
        if (this->override_mission_subfolder != 0 || writeAll)
        {
            optionsFileStream << "#Create a mission subfolder?" << std::endl;
            optionsFileStream << "override_mission_subfolder " << this->override_mission_subfolder << std::endl;
        }
    
        if (this->forced_mission_subfolder != "mission_subfolder" || writeAll)
        {
            optionsFileStream << "#Mission subfolder" << std::endl;
            optionsFileStream << "forced_mission_subfolder " << this->forced_mission_subfolder << std::endl;
        }
    
        if (this->short_output_file_names != 1 || writeAll)
        {
            optionsFileStream << "#Shorten output file names?" << std::endl;
            optionsFileStream << "short_output_file_names " << this->short_output_file_names << std::endl;
        }
    
        if (this->generate_forward_integrated_ephemeris != 0 || writeAll)
        {
            optionsFileStream << "#Generate forward-integrated ephemeris?" << std::endl;
            optionsFileStream << "generate_forward_integrated_ephemeris " << this->generate_forward_integrated_ephemeris << std::endl;
        }
    
        if (this->forward_integrated_ephemeris_central_body_SPICE_ID != 10 || writeAll)
        {
            optionsFileStream << "#SPICE ID of central body for forward integrated ephemeris" << std::endl;
            optionsFileStream << "forward_integrated_ephemeris_central_body_SPICE_ID " << this->forward_integrated_ephemeris_central_body_SPICE_ID << std::endl;
        }
    
        if (this->add_control_switch_line_to_ephemeris != 0 || writeAll)
        {
            optionsFileStream << "#Add control switch line to ephemeris?" << std::endl;
            optionsFileStream << "add_control_switch_line_to_ephemeris " << this->add_control_switch_line_to_ephemeris << std::endl;
        }
    
        if (this->append_mass_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append mass to ephemeris output?" << std::endl;
            optionsFileStream << "append_mass_to_ephemeris_output " << this->append_mass_to_ephemeris_output << std::endl;
        }
    
        if (this->append_control_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append control vector to ephemeris output?" << std::endl;
            optionsFileStream << "append_control_to_ephemeris_output " << this->append_control_to_ephemeris_output << std::endl;
        }
    
        if (this->append_thrust_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append thrust magnitude to ephemeris output?" << std::endl;
            optionsFileStream << "append_thrust_to_ephemeris_output " << this->append_thrust_to_ephemeris_output << std::endl;
        }
    
        if (this->append_mdot_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append mass flow rate to ephemeris output?" << std::endl;
            optionsFileStream << "append_mdot_to_ephemeris_output " << this->append_mdot_to_ephemeris_output << std::endl;
        }
    
        if (this->append_Isp_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append Isp to ephemeris output?" << std::endl;
            optionsFileStream << "append_Isp_to_ephemeris_output " << this->append_Isp_to_ephemeris_output << std::endl;
        }
    
        if (this->append_active_power_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append active power to ephemeris output?" << std::endl;
            optionsFileStream << "append_active_power_to_ephemeris_output " << this->append_active_power_to_ephemeris_output << std::endl;
        }
    
        if (this->append_number_of_active_engines_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append number of active propulsion systems to ephemeris output?" << std::endl;
            optionsFileStream << "append_number_of_active_engines_to_ephemeris_output " << this->append_number_of_active_engines_to_ephemeris_output << std::endl;
        }
    
        if (this->append_throttle_level_to_ephemeris_output != 0 || writeAll)
        {
            optionsFileStream << "#Append throttle level to ephemeris output?" << std::endl;
            optionsFileStream << "append_throttle_level_to_ephemeris_output " << this->append_throttle_level_to_ephemeris_output << std::endl;
        }
    
        if (this->call_system_to_generate_bsp != 0 || writeAll)
        {
            optionsFileStream << "#Generate bsp?" << std::endl;
            optionsFileStream << "call_system_to_generate_bsp " << this->call_system_to_generate_bsp << std::endl;
        }
    
        if (this->spice_utilities_path != "c:/utilities/cspice/exe" || writeAll)
        {
            optionsFileStream << "#Where are spice utilities?" << std::endl;
            optionsFileStream << "spice_utilities_path " << this->spice_utilities_path << std::endl;
        }
    
        if (this->spice_utility_extension != ".exe" || writeAll)
        {
            optionsFileStream << "#Spice utility extension" << std::endl;
            optionsFileStream << "spice_utility_extension " << this->spice_utility_extension << std::endl;
        }
    
        if (this->pyemtg_path != "c:/emtg/PyEMTG/" || writeAll)
        {
            optionsFileStream << "#PyEMTG path" << std::endl;
            optionsFileStream << "pyemtg_path " << this->pyemtg_path << std::endl;
        }
    
        if (this->spacecraft_SPICE_ID != -52284 || writeAll)
        {
            optionsFileStream << "#SPICE ID of spacecraft" << std::endl;
            optionsFileStream << "spacecraft_SPICE_ID " << this->spacecraft_SPICE_ID << std::endl;
        }
    
        if (this->background_mode != 0 || writeAll)
        {
            optionsFileStream << "#Close program after completion?" << std::endl;
            optionsFileStream << "background_mode " << this->background_mode << std::endl;
        }
    
        if (this->output_STMs != 0 || writeAll)
        {
            optionsFileStream << "#Output STMs?" << std::endl;
            optionsFileStream << "output_STMs " << this->output_STMs << std::endl;
        }
    
        if (this->output_maneuver_and_target_spec_files != 0 || writeAll)
        {
            optionsFileStream << "#Output maneuver and target spec files?" << std::endl;
            optionsFileStream << "output_maneuver_and_target_spec_files " << this->output_maneuver_and_target_spec_files << std::endl;
        }
    
        if (this->generate_acceleration_model_instrumentation_file != 0 || writeAll)
        {
            optionsFileStream << "#generates a complete output of all acceleration model data at each integration time step (only works for numerically integrated trajectories" << std::endl;
            optionsFileStream << "generate_acceleration_model_instrumentation_file " << this->generate_acceleration_model_instrumentation_file << std::endl;
        }
    
        if (this->stop_after_journey != 32767 || writeAll)
        {
            optionsFileStream << "#Stop after a particular journey? (if this value is greater than the number of journeys, do the whole mission)" << std::endl;
            optionsFileStream << "stop_after_journey " << this->stop_after_journey << std::endl;
        }
    
        if (this->run_inner_loop != 1 || writeAll)
        {
            optionsFileStream << "#which inner loop solver to run?\n#0: none, evaluate trialX\n#1: run MBH\n#2: run constrained DE\n#3: run NLP using trialX as initial guess\n#4: filament walker" << std::endl;
            optionsFileStream << "run_inner_loop " << this->run_inner_loop << std::endl;
        }
    
        if (this->check_derivatives != 0 || writeAll)
        {
            optionsFileStream << "#Check derivatives using NLP finite differencing?" << std::endl;
            optionsFileStream << "check_derivatives " << this->check_derivatives << std::endl;
        }
    
        optionsFileStream << "#Field for taking notes" << std::endl;
        optionsFileStream << "user_data " << this->user_data << std::endl;
    
        optionsFileStream << std::endl;
        optionsFileStream << std::endl;
    
        //write the journeys
        optionsFileStream.close();
        for (EMTG::JourneyOptions myJourney : this->Journeys)
            myJourney.write(optionsFileName, false, writeAll);
    }//end write()
    
    //method to assemble the mission-level initial guess vector
    void missionoptions::assemble_initial_guess()
    {
        this->trialX.clear();
        
        for (size_t journeyIndex = 0; journeyIndex < this->number_of_journeys; ++journeyIndex)
        {
            std::tuple<std::string, double> newEntry;
            std::string prefix("j" + std::to_string(journeyIndex));
            
            for (std::tuple<std::string, double>& entry : this->Journeys[journeyIndex].trialX)
            {
                std::get<0>(newEntry) = prefix + std::get<0>(entry);
                std::get<1>(newEntry) = std::get<1>(entry);
                this->trialX.push_back(newEntry);
            }
        }
    }//end assemble_initial_guess()
}//close namespace EMTG
